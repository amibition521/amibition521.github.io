<!doctype html>




<html class="theme-next pisces" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="上周四去分享销客面试，整个过程面试官就问了一个问题：listview；其中涉及获得 listview 中的父控件中的子控件、listview 的优化(卡顿、层级)、listview 的性能提升以及查看 listview 性能的工具；坦白来讲，对于最后一个问题，我表示面试官很坑啊，listview 的监测工具 ??? 大写的什么鬼？ 你怎么不直接问我检测内存的工具呢？我表示很懵逼啊；我表示不服，必须">
<meta name="keywords">
<meta property="og:type" content="article">
<meta property="og:title" content="Listview 原理解析">
<meta property="og:url" content="http://yoursite.com/2017/04/23/Listview-原理解析/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="上周四去分享销客面试，整个过程面试官就问了一个问题：listview；其中涉及获得 listview 中的父控件中的子控件、listview 的优化(卡顿、层级)、listview 的性能提升以及查看 listview 性能的工具；坦白来讲，对于最后一个问题，我表示面试官很坑啊，listview 的监测工具 ??? 大写的什么鬼？ 你怎么不直接问我检测内存的工具呢？我表示很懵逼啊；我表示不服，必须">
<meta property="og:updated_time" content="2017-04-24T15:49:56.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Listview 原理解析">
<meta name="twitter:description" content="上周四去分享销客面试，整个过程面试官就问了一个问题：listview；其中涉及获得 listview 中的父控件中的子控件、listview 的优化(卡顿、层级)、listview 的性能提升以及查看 listview 性能的工具；坦白来讲，对于最后一个问题，我表示面试官很坑啊，listview 的监测工具 ??? 大写的什么鬼？ 你怎么不直接问我检测内存的工具呢？我表示很懵逼啊；我表示不服，必须">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: false,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/04/23/Listview-原理解析/"/>





  <title> Listview 原理解析 | Hexo </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/23/Listview-原理解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangzaidong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Listview 原理解析
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-23T12:09:07+08:00">
                2017-04-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>上周四去分享销客面试，整个过程面试官就问了一个问题：listview；其中涉及获得 listview 中的父控件中的子控件、listview 的优化(卡顿、层级)、listview 的性能提升以及查看 listview 性能的工具；坦白来讲，对于最后一个问题，我表示面试官很坑啊，listview 的监测工具 ??? 大写的什么鬼？ 你怎么不直接问我检测内存的工具呢？我表示很懵逼啊；我表示不服，必须重新撸一遍 listview 的源码，以解我心头之恨。</p>
<h4 id="Adapter-的作用"><a href="#Adapter-的作用" class="headerlink" title="Adapter 的作用"></a>Adapter 的作用</h4><p>我们都知道 listview  中是没有数据的，所有的数据都是通过 adapter 这个接口来获得的，它可以实现各种各样的子类，每个子类都会通过自己的逻辑来适配不同的数据源；</p>
<h4 id="RecycleBin-机制"><a href="#RecycleBin-机制" class="headerlink" title="RecycleBin 机制"></a>RecycleBin 机制</h4><p>它是 AbsListView 的内部类，ListView 和 GridView 都继承自 AbsListView类；RecycleBin 保证了 listview 加载上千条 item 都不会出现 OOM 的情况 ;源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div><div class="line">345</div><div class="line">346</div><div class="line">347</div><div class="line">348</div><div class="line">349</div><div class="line">350</div><div class="line">351</div><div class="line">352</div><div class="line">353</div><div class="line">354</div><div class="line">355</div><div class="line">356</div><div class="line">357</div><div class="line">358</div><div class="line">359</div><div class="line">360</div><div class="line">361</div><div class="line">362</div><div class="line">363</div><div class="line">364</div><div class="line">365</div><div class="line">366</div><div class="line">367</div><div class="line">368</div><div class="line">369</div><div class="line">370</div><div class="line">371</div><div class="line">372</div><div class="line">373</div><div class="line">374</div><div class="line">375</div><div class="line">376</div><div class="line">377</div><div class="line">378</div><div class="line">379</div><div class="line">380</div><div class="line">381</div><div class="line">382</div><div class="line">383</div><div class="line">384</div><div class="line">385</div><div class="line">386</div><div class="line">387</div><div class="line">388</div><div class="line">389</div><div class="line">390</div><div class="line">391</div><div class="line">392</div><div class="line">393</div><div class="line">394</div><div class="line">395</div><div class="line">396</div><div class="line">397</div><div class="line">398</div><div class="line">399</div><div class="line">400</div><div class="line">401</div><div class="line">402</div><div class="line">403</div><div class="line">404</div><div class="line">405</div><div class="line">406</div><div class="line">407</div><div class="line">408</div><div class="line">409</div><div class="line">410</div><div class="line">411</div><div class="line">412</div><div class="line">413</div><div class="line">414</div><div class="line">415</div><div class="line">416</div><div class="line">417</div><div class="line">418</div><div class="line">419</div><div class="line">420</div><div class="line">421</div><div class="line">422</div><div class="line">423</div><div class="line">424</div><div class="line">425</div><div class="line">426</div><div class="line">427</div><div class="line">428</div><div class="line">429</div><div class="line">430</div><div class="line">431</div><div class="line">432</div><div class="line">433</div><div class="line">434</div><div class="line">435</div><div class="line">436</div><div class="line">437</div><div class="line">438</div><div class="line">439</div><div class="line">440</div><div class="line">441</div><div class="line">442</div><div class="line">443</div><div class="line">444</div><div class="line">445</div><div class="line">446</div><div class="line">447</div><div class="line">448</div><div class="line">449</div><div class="line">450</div><div class="line">451</div><div class="line">452</div><div class="line">453</div><div class="line">454</div><div class="line">455</div><div class="line">456</div><div class="line">457</div><div class="line">458</div><div class="line">459</div><div class="line">460</div><div class="line">461</div><div class="line">462</div><div class="line">463</div><div class="line">464</div><div class="line">465</div><div class="line">466</div><div class="line">467</div><div class="line">468</div><div class="line">469</div><div class="line">470</div><div class="line">471</div><div class="line">472</div><div class="line">473</div><div class="line">474</div><div class="line">475</div><div class="line">476</div><div class="line">477</div><div class="line">478</div><div class="line">479</div><div class="line">480</div><div class="line">481</div><div class="line">482</div><div class="line">483</div><div class="line">484</div><div class="line">485</div><div class="line">486</div><div class="line">487</div><div class="line">488</div><div class="line">489</div><div class="line">490</div><div class="line">491</div><div class="line">492</div><div class="line">493</div><div class="line">494</div><div class="line">495</div><div class="line">496</div><div class="line">497</div><div class="line">498</div><div class="line">499</div><div class="line">500</div><div class="line">501</div><div class="line">502</div><div class="line">503</div><div class="line">504</div><div class="line">505</div><div class="line">506</div><div class="line">507</div><div class="line">508</div><div class="line">509</div><div class="line">510</div><div class="line">511</div><div class="line">512</div><div class="line">513</div><div class="line">514</div><div class="line">515</div><div class="line">516</div><div class="line">517</div><div class="line">518</div><div class="line">519</div><div class="line">520</div><div class="line">521</div><div class="line">522</div><div class="line">523</div><div class="line">524</div><div class="line">525</div><div class="line">526</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * The RecycleBin facilitates reuse of views across layouts. The RecycleBin has two levels of</div><div class="line">     * storage: ActiveViews and ScrapViews. ActiveViews are those views which were onscreen at the</div><div class="line">     * start of a layout. By construction, they are displaying current information. At the end of</div><div class="line">     * layout, all views in ActiveViews are demoted to ScrapViews. ScrapViews are old views that</div><div class="line">     * could potentially be used by the adapter to avoid allocating views unnecessarily.</div><div class="line">     *</div><div class="line">     * @see android.widget.AbsListView#setRecyclerListener(android.widget.AbsListView.RecyclerListener)</div><div class="line">     * @see android.widget.AbsListView.RecyclerListener</div><div class="line">     */</div><div class="line">    class RecycleBin &#123;</div><div class="line">        private RecyclerListener mRecyclerListener;</div><div class="line"></div><div class="line">        /**</div><div class="line">         * The position of the first view stored in mActiveViews.</div><div class="line">         */</div><div class="line">        private int mFirstActivePosition;</div><div class="line"></div><div class="line">        /**</div><div class="line">         * Views that were on screen at the start of layout. This array is populated at the start of</div><div class="line">         * layout, and at the end of layout all view in mActiveViews are moved to mScrapViews.</div><div class="line">         * Views in mActiveViews represent a contiguous range of Views, with position of the first</div><div class="line">         * view store in mFirstActivePosition.</div><div class="line">         */</div><div class="line">        private View[] mActiveViews = new View[0];</div><div class="line"></div><div class="line">        /**</div><div class="line">         * Unsorted views that can be used by the adapter as a convert view.</div><div class="line">         */</div><div class="line">        private ArrayList&lt;View&gt;[] mScrapViews;</div><div class="line"></div><div class="line">        private int mViewTypeCount;</div><div class="line"></div><div class="line">        private ArrayList&lt;View&gt; mCurrentScrap;</div><div class="line"></div><div class="line">        private ArrayList&lt;View&gt; mSkippedScrap;</div><div class="line"></div><div class="line">        private SparseArray&lt;View&gt; mTransientStateViews;</div><div class="line">        private LongSparseArray&lt;View&gt; mTransientStateViewsById;</div><div class="line"></div><div class="line">        public void setViewTypeCount(int viewTypeCount) &#123;</div><div class="line">            if (viewTypeCount &lt; 1) &#123;</div><div class="line">                throw new IllegalArgumentException(&quot;Can&apos;t have a viewTypeCount &lt; 1&quot;);</div><div class="line">            &#125;</div><div class="line">            //noinspection unchecked</div><div class="line">            ArrayList&lt;View&gt;[] scrapViews = new ArrayList[viewTypeCount];</div><div class="line">            for (int i = 0; i &lt; viewTypeCount; i++) &#123;</div><div class="line">                scrapViews[i] = new ArrayList&lt;View&gt;();</div><div class="line">            &#125;</div><div class="line">            mViewTypeCount = viewTypeCount;</div><div class="line">            mCurrentScrap = scrapViews[0];</div><div class="line">            mScrapViews = scrapViews;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public void markChildrenDirty() &#123;</div><div class="line">            if (mViewTypeCount == 1) &#123;</div><div class="line">                final ArrayList&lt;View&gt; scrap = mCurrentScrap;</div><div class="line">                final int scrapCount = scrap.size();</div><div class="line">                for (int i = 0; i &lt; scrapCount; i++) &#123;</div><div class="line">                    scrap.get(i).forceLayout();</div><div class="line">                &#125;</div><div class="line">            &#125; else &#123;</div><div class="line">                final int typeCount = mViewTypeCount;</div><div class="line">                for (int i = 0; i &lt; typeCount; i++) &#123;</div><div class="line">                    final ArrayList&lt;View&gt; scrap = mScrapViews[i];</div><div class="line">                    final int scrapCount = scrap.size();</div><div class="line">                    for (int j = 0; j &lt; scrapCount; j++) &#123;</div><div class="line">                        scrap.get(j).forceLayout();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            if (mTransientStateViews != null) &#123;</div><div class="line">                final int count = mTransientStateViews.size();</div><div class="line">                for (int i = 0; i &lt; count; i++) &#123;</div><div class="line">                    mTransientStateViews.valueAt(i).forceLayout();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            if (mTransientStateViewsById != null) &#123;</div><div class="line">                final int count = mTransientStateViewsById.size();</div><div class="line">                for (int i = 0; i &lt; count; i++) &#123;</div><div class="line">                    mTransientStateViewsById.valueAt(i).forceLayout();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public boolean shouldRecycleViewType(int viewType) &#123;</div><div class="line">            return viewType &gt;= 0;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        /**</div><div class="line">         * Clears the scrap heap.</div><div class="line">         */</div><div class="line">        void clear() &#123;</div><div class="line">            if (mViewTypeCount == 1) &#123;</div><div class="line">                final ArrayList&lt;View&gt; scrap = mCurrentScrap;</div><div class="line">                clearScrap(scrap);</div><div class="line">            &#125; else &#123;</div><div class="line">                final int typeCount = mViewTypeCount;</div><div class="line">                for (int i = 0; i &lt; typeCount; i++) &#123;</div><div class="line">                    final ArrayList&lt;View&gt; scrap = mScrapViews[i];</div><div class="line">                    clearScrap(scrap);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            clearTransientStateViews();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        /**</div><div class="line">         * Fill ActiveViews with all of the children of the AbsListView.</div><div class="line">         *</div><div class="line">         * @param childCount The minimum number of views mActiveViews should hold</div><div class="line">         * @param firstActivePosition The position of the first view that will be stored in</div><div class="line">         *        mActiveViews</div><div class="line">         */</div><div class="line">        void fillActiveViews(int childCount, int firstActivePosition) &#123;</div><div class="line">            if (mActiveViews.length &lt; childCount) &#123;</div><div class="line">                mActiveViews = new View[childCount];</div><div class="line">            &#125;</div><div class="line">            mFirstActivePosition = firstActivePosition;</div><div class="line"></div><div class="line">            //noinspection MismatchedReadAndWriteOfArray</div><div class="line">            final View[] activeViews = mActiveViews;</div><div class="line">            for (int i = 0; i &lt; childCount; i++) &#123;</div><div class="line">                View child = getChildAt(i);</div><div class="line">                AbsListView.LayoutParams lp = (AbsListView.LayoutParams) child.getLayoutParams();</div><div class="line">                // Don&apos;t put header or footer views into the scrap heap</div><div class="line">                if (lp != null &amp;&amp; lp.viewType != ITEM_VIEW_TYPE_HEADER_OR_FOOTER) &#123;</div><div class="line">                    // Note:  We do place AdapterView.ITEM_VIEW_TYPE_IGNORE in active views.</div><div class="line">                    //        However, we will NOT place them into scrap views.</div><div class="line">                    activeViews[i] = child;</div><div class="line">                    // Remember the position so that setupChild() doesn&apos;t reset state.</div><div class="line">                    lp.scrappedFromPosition = firstActivePosition + i;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        /**</div><div class="line">         * Get the view corresponding to the specified position. The view will be removed from</div><div class="line">         * mActiveViews if it is found.</div><div class="line">         *</div><div class="line">         * @param position The position to look up in mActiveViews</div><div class="line">         * @return The view if it is found, null otherwise</div><div class="line">         */</div><div class="line">        View getActiveView(int position) &#123;</div><div class="line">            int index = position - mFirstActivePosition;</div><div class="line">            final View[] activeViews = mActiveViews;</div><div class="line">            if (index &gt;=0 &amp;&amp; index &lt; activeViews.length) &#123;</div><div class="line">                final View match = activeViews[index];</div><div class="line">                activeViews[index] = null;</div><div class="line">                return match;</div><div class="line">            &#125;</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        View getTransientStateView(int position) &#123;</div><div class="line">            if (mAdapter != null &amp;&amp; mAdapterHasStableIds &amp;&amp; mTransientStateViewsById != null) &#123;</div><div class="line">                long id = mAdapter.getItemId(position);</div><div class="line">                View result = mTransientStateViewsById.get(id);</div><div class="line">                mTransientStateViewsById.remove(id);</div><div class="line">                return result;</div><div class="line">            &#125;</div><div class="line">            if (mTransientStateViews != null) &#123;</div><div class="line">                final int index = mTransientStateViews.indexOfKey(position);</div><div class="line">                if (index &gt;= 0) &#123;</div><div class="line">                    View result = mTransientStateViews.valueAt(index);</div><div class="line">                    mTransientStateViews.removeAt(index);</div><div class="line">                    return result;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        /**</div><div class="line">         * Dumps and fully detaches any currently saved views with transient</div><div class="line">         * state.</div><div class="line">         */</div><div class="line">        void clearTransientStateViews() &#123;</div><div class="line">            final SparseArray&lt;View&gt; viewsByPos = mTransientStateViews;</div><div class="line">            if (viewsByPos != null) &#123;</div><div class="line">                final int N = viewsByPos.size();</div><div class="line">                for (int i = 0; i &lt; N; i++) &#123;</div><div class="line">                    removeDetachedView(viewsByPos.valueAt(i), false);</div><div class="line">                &#125;</div><div class="line">                viewsByPos.clear();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            final LongSparseArray&lt;View&gt; viewsById = mTransientStateViewsById;</div><div class="line">            if (viewsById != null) &#123;</div><div class="line">                final int N = viewsById.size();</div><div class="line">                for (int i = 0; i &lt; N; i++) &#123;</div><div class="line">                    removeDetachedView(viewsById.valueAt(i), false);</div><div class="line">                &#125;</div><div class="line">                viewsById.clear();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        /**</div><div class="line">         * @return A view from the ScrapViews collection. These are unordered.</div><div class="line">         */</div><div class="line">        View getScrapView(int position) &#123;</div><div class="line">            final int whichScrap = mAdapter.getItemViewType(position);</div><div class="line">            if (whichScrap &lt; 0) &#123;</div><div class="line">                return null;</div><div class="line">            &#125;</div><div class="line">            if (mViewTypeCount == 1) &#123;</div><div class="line">                return retrieveFromScrap(mCurrentScrap, position);</div><div class="line">            &#125; else if (whichScrap &lt; mScrapViews.length) &#123;</div><div class="line">                return retrieveFromScrap(mScrapViews[whichScrap], position);</div><div class="line">            &#125;</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        /**</div><div class="line">         * Puts a view into the list of scrap views.</div><div class="line">         * &lt;p&gt;</div><div class="line">         * If the list data hasn&apos;t changed or the adapter has stable IDs, views</div><div class="line">         * with transient state will be preserved for later retrieval.</div><div class="line">         *</div><div class="line">         * @param scrap The view to add</div><div class="line">         * @param position The view&apos;s position within its parent</div><div class="line">         */</div><div class="line">        void addScrapView(View scrap, int position) &#123;</div><div class="line">            final AbsListView.LayoutParams lp = (AbsListView.LayoutParams) scrap.getLayoutParams();</div><div class="line">            if (lp == null) &#123;</div><div class="line">                // Can&apos;t recycle, but we don&apos;t know anything about the view.</div><div class="line">                // Ignore it completely.</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            lp.scrappedFromPosition = position;</div><div class="line"></div><div class="line">            // Remove but don&apos;t scrap header or footer views, or views that</div><div class="line">            // should otherwise not be recycled.</div><div class="line">            final int viewType = lp.viewType;</div><div class="line">            if (!shouldRecycleViewType(viewType)) &#123;</div><div class="line">                // Can&apos;t recycle. If it&apos;s not a header or footer, which have</div><div class="line">                // special handling and should be ignored, then skip the scrap</div><div class="line">                // heap and we&apos;ll fully detach the view later.</div><div class="line">                if (viewType != ITEM_VIEW_TYPE_HEADER_OR_FOOTER) &#123;</div><div class="line">                    getSkippedScrap().add(scrap);</div><div class="line">                &#125;</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            scrap.dispatchStartTemporaryDetach();</div><div class="line"></div><div class="line">            // The the accessibility state of the view may change while temporary</div><div class="line">            // detached and we do not allow detached views to fire accessibility</div><div class="line">            // events. So we are announcing that the subtree changed giving a chance</div><div class="line">            // to clients holding on to a view in this subtree to refresh it.</div><div class="line">            notifyViewAccessibilityStateChangedIfNeeded(</div><div class="line">                    AccessibilityEvent.CONTENT_CHANGE_TYPE_SUBTREE);</div><div class="line"></div><div class="line">            // Don&apos;t scrap views that have transient state.</div><div class="line">            final boolean scrapHasTransientState = scrap.hasTransientState();</div><div class="line">            if (scrapHasTransientState) &#123;</div><div class="line">                if (mAdapter != null &amp;&amp; mAdapterHasStableIds) &#123;</div><div class="line">                    // If the adapter has stable IDs, we can reuse the view for</div><div class="line">                    // the same data.</div><div class="line">                    if (mTransientStateViewsById == null) &#123;</div><div class="line">                        mTransientStateViewsById = new LongSparseArray&lt;&gt;();</div><div class="line">                    &#125;</div><div class="line">                    mTransientStateViewsById.put(lp.itemId, scrap);</div><div class="line">                &#125; else if (!mDataChanged) &#123;</div><div class="line">                    // If the data hasn&apos;t changed, we can reuse the views at</div><div class="line">                    // their old positions.</div><div class="line">                    if (mTransientStateViews == null) &#123;</div><div class="line">                        mTransientStateViews = new SparseArray&lt;&gt;();</div><div class="line">                    &#125;</div><div class="line">                    mTransientStateViews.put(position, scrap);</div><div class="line">                &#125; else &#123;</div><div class="line">                    // Otherwise, we&apos;ll have to remove the view and start over.</div><div class="line">                    getSkippedScrap().add(scrap);</div><div class="line">                &#125;</div><div class="line">            &#125; else &#123;</div><div class="line">                if (mViewTypeCount == 1) &#123;</div><div class="line">                    mCurrentScrap.add(scrap);</div><div class="line">                &#125; else &#123;</div><div class="line">                    mScrapViews[viewType].add(scrap);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                if (mRecyclerListener != null) &#123;</div><div class="line">                    mRecyclerListener.onMovedToScrapHeap(scrap);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        private ArrayList&lt;View&gt; getSkippedScrap() &#123;</div><div class="line">            if (mSkippedScrap == null) &#123;</div><div class="line">                mSkippedScrap = new ArrayList&lt;&gt;();</div><div class="line">            &#125;</div><div class="line">            return mSkippedScrap;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        /**</div><div class="line">         * Finish the removal of any views that skipped the scrap heap.</div><div class="line">         */</div><div class="line">        void removeSkippedScrap() &#123;</div><div class="line">            if (mSkippedScrap == null) &#123;</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">            final int count = mSkippedScrap.size();</div><div class="line">            for (int i = 0; i &lt; count; i++) &#123;</div><div class="line">                removeDetachedView(mSkippedScrap.get(i), false);</div><div class="line">            &#125;</div><div class="line">            mSkippedScrap.clear();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        /**</div><div class="line">         * Move all views remaining in mActiveViews to mScrapViews.</div><div class="line">         */</div><div class="line">        void scrapActiveViews() &#123;</div><div class="line">            final View[] activeViews = mActiveViews;</div><div class="line">            final boolean hasListener = mRecyclerListener != null;</div><div class="line">            final boolean multipleScraps = mViewTypeCount &gt; 1;</div><div class="line"></div><div class="line">            ArrayList&lt;View&gt; scrapViews = mCurrentScrap;</div><div class="line">            final int count = activeViews.length;</div><div class="line">            for (int i = count - 1; i &gt;= 0; i--) &#123;</div><div class="line">                final View victim = activeViews[i];</div><div class="line">                if (victim != null) &#123;</div><div class="line">                    final AbsListView.LayoutParams lp</div><div class="line">                            = (AbsListView.LayoutParams) victim.getLayoutParams();</div><div class="line">                    final int whichScrap = lp.viewType;</div><div class="line"></div><div class="line">                    activeViews[i] = null;</div><div class="line"></div><div class="line">                    if (victim.hasTransientState()) &#123;</div><div class="line">                        // Store views with transient state for later use.</div><div class="line">                        victim.dispatchStartTemporaryDetach();</div><div class="line"></div><div class="line">                        if (mAdapter != null &amp;&amp; mAdapterHasStableIds) &#123;</div><div class="line">                            if (mTransientStateViewsById == null) &#123;</div><div class="line">                                mTransientStateViewsById = new LongSparseArray&lt;View&gt;();</div><div class="line">                            &#125;</div><div class="line">                            long id = mAdapter.getItemId(mFirstActivePosition + i);</div><div class="line">                            mTransientStateViewsById.put(id, victim);</div><div class="line">                        &#125; else if (!mDataChanged) &#123;</div><div class="line">                            if (mTransientStateViews == null) &#123;</div><div class="line">                                mTransientStateViews = new SparseArray&lt;View&gt;();</div><div class="line">                            &#125;</div><div class="line">                            mTransientStateViews.put(mFirstActivePosition + i, victim);</div><div class="line">                        &#125; else if (whichScrap != ITEM_VIEW_TYPE_HEADER_OR_FOOTER) &#123;</div><div class="line">                            // The data has changed, we can&apos;t keep this view.</div><div class="line">                            removeDetachedView(victim, false);</div><div class="line">                        &#125;</div><div class="line">                    &#125; else if (!shouldRecycleViewType(whichScrap)) &#123;</div><div class="line">                        // Discard non-recyclable views except headers/footers.</div><div class="line">                        if (whichScrap != ITEM_VIEW_TYPE_HEADER_OR_FOOTER) &#123;</div><div class="line">                            removeDetachedView(victim, false);</div><div class="line">                        &#125;</div><div class="line">                    &#125; else &#123;</div><div class="line">                        // Store everything else on the appropriate scrap heap.</div><div class="line">                        if (multipleScraps) &#123;</div><div class="line">                            scrapViews = mScrapViews[whichScrap];</div><div class="line">                        &#125;</div><div class="line"></div><div class="line">                        lp.scrappedFromPosition = mFirstActivePosition + i;</div><div class="line">                        removeDetachedView(victim, false);</div><div class="line">                        scrapViews.add(victim);</div><div class="line"></div><div class="line">                        if (hasListener) &#123;</div><div class="line">                            mRecyclerListener.onMovedToScrapHeap(victim);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            pruneScrapViews();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        /**</div><div class="line">         * At the end of a layout pass, all temp detached views should either be re-attached or</div><div class="line">         * completely detached. This method ensures that any remaining view in the scrap list is</div><div class="line">         * fully detached.</div><div class="line">         */</div><div class="line">        void fullyDetachScrapViews() &#123;</div><div class="line">            final int viewTypeCount = mViewTypeCount;</div><div class="line">            final ArrayList&lt;View&gt;[] scrapViews = mScrapViews;</div><div class="line">            for (int i = 0; i &lt; viewTypeCount; ++i) &#123;</div><div class="line">                final ArrayList&lt;View&gt; scrapPile = scrapViews[i];</div><div class="line">                for (int j = scrapPile.size() - 1; j &gt;= 0; j--) &#123;</div><div class="line">                    final View view = scrapPile.get(j);</div><div class="line">                    if (view.isTemporarilyDetached()) &#123;</div><div class="line">                        removeDetachedView(view, false);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        /**</div><div class="line">         * Makes sure that the size of mScrapViews does not exceed the size of</div><div class="line">         * mActiveViews, which can happen if an adapter does not recycle its</div><div class="line">         * views. Removes cached transient state views that no longer have</div><div class="line">         * transient state.</div><div class="line">         */</div><div class="line">        private void pruneScrapViews() &#123;</div><div class="line">            final int maxViews = mActiveViews.length;</div><div class="line">            final int viewTypeCount = mViewTypeCount;</div><div class="line">            final ArrayList&lt;View&gt;[] scrapViews = mScrapViews;</div><div class="line">            for (int i = 0; i &lt; viewTypeCount; ++i) &#123;</div><div class="line">                final ArrayList&lt;View&gt; scrapPile = scrapViews[i];</div><div class="line">                int size = scrapPile.size();</div><div class="line">                while (size &gt; maxViews) &#123;</div><div class="line">                    scrapPile.remove(--size);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            final SparseArray&lt;View&gt; transViewsByPos = mTransientStateViews;</div><div class="line">            if (transViewsByPos != null) &#123;</div><div class="line">                for (int i = 0; i &lt; transViewsByPos.size(); i++) &#123;</div><div class="line">                    final View v = transViewsByPos.valueAt(i);</div><div class="line">                    if (!v.hasTransientState()) &#123;</div><div class="line">                        removeDetachedView(v, false);</div><div class="line">                        transViewsByPos.removeAt(i);</div><div class="line">                        i--;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            final LongSparseArray&lt;View&gt; transViewsById = mTransientStateViewsById;</div><div class="line">            if (transViewsById != null) &#123;</div><div class="line">                for (int i = 0; i &lt; transViewsById.size(); i++) &#123;</div><div class="line">                    final View v = transViewsById.valueAt(i);</div><div class="line">                    if (!v.hasTransientState()) &#123;</div><div class="line">                        removeDetachedView(v, false);</div><div class="line">                        transViewsById.removeAt(i);</div><div class="line">                        i--;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        /**</div><div class="line">         * Puts all views in the scrap heap into the supplied list.</div><div class="line">         */</div><div class="line">        void reclaimScrapViews(List&lt;View&gt; views) &#123;</div><div class="line">            if (mViewTypeCount == 1) &#123;</div><div class="line">                views.addAll(mCurrentScrap);</div><div class="line">            &#125; else &#123;</div><div class="line">                final int viewTypeCount = mViewTypeCount;</div><div class="line">                final ArrayList&lt;View&gt;[] scrapViews = mScrapViews;</div><div class="line">                for (int i = 0; i &lt; viewTypeCount; ++i) &#123;</div><div class="line">                    final ArrayList&lt;View&gt; scrapPile = scrapViews[i];</div><div class="line">                    views.addAll(scrapPile);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        /**</div><div class="line">         * Updates the cache color hint of all known views.</div><div class="line">         *</div><div class="line">         * @param color The new cache color hint.</div><div class="line">         */</div><div class="line">        void setCacheColorHint(int color) &#123;</div><div class="line">            if (mViewTypeCount == 1) &#123;</div><div class="line">                final ArrayList&lt;View&gt; scrap = mCurrentScrap;</div><div class="line">                final int scrapCount = scrap.size();</div><div class="line">                for (int i = 0; i &lt; scrapCount; i++) &#123;</div><div class="line">                    scrap.get(i).setDrawingCacheBackgroundColor(color);</div><div class="line">                &#125;</div><div class="line">            &#125; else &#123;</div><div class="line">                final int typeCount = mViewTypeCount;</div><div class="line">                for (int i = 0; i &lt; typeCount; i++) &#123;</div><div class="line">                    final ArrayList&lt;View&gt; scrap = mScrapViews[i];</div><div class="line">                    final int scrapCount = scrap.size();</div><div class="line">                    for (int j = 0; j &lt; scrapCount; j++) &#123;</div><div class="line">                        scrap.get(j).setDrawingCacheBackgroundColor(color);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            // Just in case this is called during a layout pass</div><div class="line">            final View[] activeViews = mActiveViews;</div><div class="line">            final int count = activeViews.length;</div><div class="line">            for (int i = 0; i &lt; count; ++i) &#123;</div><div class="line">                final View victim = activeViews[i];</div><div class="line">                if (victim != null) &#123;</div><div class="line">                    victim.setDrawingCacheBackgroundColor(color);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        private View retrieveFromScrap(ArrayList&lt;View&gt; scrapViews, int position) &#123;</div><div class="line">            final int size = scrapViews.size();</div><div class="line">            if (size &gt; 0) &#123;</div><div class="line">                // See if we still have a view for this position or ID.</div><div class="line">                for (int i = 0; i &lt; size; i++) &#123;</div><div class="line">                    final View view = scrapViews.get(i);</div><div class="line">                    final AbsListView.LayoutParams params =</div><div class="line">                            (AbsListView.LayoutParams) view.getLayoutParams();</div><div class="line"></div><div class="line">                    if (mAdapterHasStableIds) &#123;</div><div class="line">                        final long id = mAdapter.getItemId(position);</div><div class="line">                        if (id == params.itemId) &#123;</div><div class="line">                            return scrapViews.remove(i);</div><div class="line">                        &#125;</div><div class="line">                    &#125; else if (params.scrappedFromPosition == position) &#123;</div><div class="line">                        final View scrap = scrapViews.remove(i);</div><div class="line">                        clearAccessibilityFromScrap(scrap);</div><div class="line">                        return scrap;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                final View scrap = scrapViews.remove(size - 1);</div><div class="line">                clearAccessibilityFromScrap(scrap);</div><div class="line">                return scrap;</div><div class="line">            &#125; else &#123;</div><div class="line">                return null;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        private void clearScrap(final ArrayList&lt;View&gt; scrap) &#123;</div><div class="line">            final int scrapCount = scrap.size();</div><div class="line">            for (int j = 0; j &lt; scrapCount; j++) &#123;</div><div class="line">                removeDetachedView(scrap.remove(scrapCount - 1 - j), false);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        private void clearAccessibilityFromScrap(View view) &#123;</div><div class="line">            view.clearAccessibilityFocus();</div><div class="line">            view.setAccessibilityDelegate(null);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        private void removeDetachedView(View child, boolean animate) &#123;</div><div class="line">            child.setAccessibilityDelegate(null);</div><div class="line">            AbsListView.this.removeDetachedView(child, animate);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>在 RecycleBin 中有两个数组：mActiveViews 和 mScrapViews; mActiveViews 表示 listview 首屏展示的元素集合,mScrapViews 表示屏幕外被废弃的元素集合，它是无序的；这里面有几个非常重要的方法，我们现在逐一看看：</p>
<ul>
<li><strong>fillActiveViews()</strong>  这个方法接收两个参数，第一个参数是要存储的 view 的数量，第二个参数是 listview 中第一个可见元素的 position;RecycleBin 中使用 mActiveViews 这个数组来存储 view；调用这个方法是将 AbsListView 中所有的子元素全部添加到 mActiveViews 中。</li>
<li><strong>getActiveView()</strong> 用于从mActiveViews 中获取元素。传入的 position 参数表示元素在 listview 中的位置，方法内部会自动转化成mActiveViews 数组中的下标值。 有一点需要注意：mActiveViews 中的 view 一旦被获取之后就会从 mActiveViews 中移除，下次在获取同样位置的 view 将会返回 null；也就是说 mActiveViews 不能被重复利用。</li>
<li><strong>addScrapView()</strong> 用于将一个废弃的 View 进行缓存；该方法接收两个参数，第一个参数表示要回收的 View ，第二个参数表示在父布局上的位置。RecycleBin 使用了 mScrapView 和 mCurrentScrap 两个 list 来存储废弃的 View。</li>
<li><strong>getScrapView()</strong> 用于从废弃缓存中取出一个 View ,该方法接收一个 position 参数，表示取出父布局上这个位置的 View；由于缓存中的 View 是无序的，因此这里面有一个判断，<ul>
<li>如果只有一个元素，那就从 mCurrentScrap 中取；如果这个 position中的 View 还存在（ID ／Position），那么就从 mCurrentScrap 中取出，如果不存在就取 mCurrentScrap 中的最后一个；</li>
<li>如果这个 position 小于 mScrapViews 的长度，那么就从 mScrapViews 中取，同样的，如果这个 position中的 View 还存在（ID ／Position），那么就从 mScrapViews 中取出，如果不存在就取 mScrapViews 中的最后一个；</li>
</ul>
</li>
<li><strong>setViewTypeCount()</strong>  作用是为每种类型的数据项单独启用一个 RecycleBin 缓存机制；</li>
</ul>
<h4 id="第一次-Layout"><a href="#第一次-Layout" class="headerlink" title="第一次 Layout"></a>第一次 Layout</h4><p>在 ListView 中我们并没有找到 onLayout() 方法，那一定是在父类中实现该方法，我们在AbsListView 中找到了这个方法，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * Subclasses should NOT override this method but</div><div class="line">     *  &#123;@link #layoutChildren()&#125; instead.</div><div class="line">     */</div><div class="line">    @Override</div><div class="line">    protected void onLayout(boolean changed, int l, int t, int r, int b) &#123;</div><div class="line">        super.onLayout(changed, l, t, r, b);</div><div class="line"></div><div class="line">        mInLayout = true;</div><div class="line"></div><div class="line">        final int childCount = getChildCount();</div><div class="line">        if (changed) &#123;</div><div class="line">            for (int i = 0; i &lt; childCount; i++) &#123;</div><div class="line">                getChildAt(i).forceLayout();</div><div class="line">            &#125;</div><div class="line">            mRecycler.markChildrenDirty();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        layoutChildren();</div><div class="line"></div><div class="line">        mOverscrollMax = (b - t) / OVERSCROLL_LIMIT_DIVISOR;</div><div class="line"></div><div class="line">        // TODO: Move somewhere sane. This doesn&apos;t belong in onLayout().</div><div class="line">        if (mFastScroll != null) &#123;</div><div class="line">            mFastScroll.onItemCountChanged(getChildCount(), mItemCount);</div><div class="line">        &#125;</div><div class="line">        mInLayout = false;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>从这个方法的声明中我们知道，子类不需要重写这个方法，相应的子类应该重写 LayoutChildren() 方法；这也不难理解，因为子元素的布局应该由具体的实现类来完成，而不是父类来完成。</p>
<p>Listview 中的 LayoutChildren() 方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div><div class="line">345</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">    protected void layoutChildren() &#123;</div><div class="line">        final boolean blockLayoutRequests = mBlockLayoutRequests;</div><div class="line">        if (blockLayoutRequests) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        mBlockLayoutRequests = true;</div><div class="line"></div><div class="line">        try &#123;</div><div class="line">            super.layoutChildren();</div><div class="line"></div><div class="line">            invalidate();</div><div class="line"></div><div class="line">            if (mAdapter == null) &#123;</div><div class="line">                resetList();</div><div class="line">                invokeOnItemScrollListener();</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            final int childrenTop = mListPadding.top;</div><div class="line">            final int childrenBottom = mBottom - mTop - mListPadding.bottom;</div><div class="line">            final int childCount = getChildCount();</div><div class="line"></div><div class="line">            int index = 0;</div><div class="line">            int delta = 0;</div><div class="line"></div><div class="line">            View sel;</div><div class="line">            View oldSel = null;</div><div class="line">            View oldFirst = null;</div><div class="line">            View newSel = null;</div><div class="line"></div><div class="line">            // Remember stuff we will need down below</div><div class="line">            switch (mLayoutMode) &#123;</div><div class="line">            case LAYOUT_SET_SELECTION:</div><div class="line">                index = mNextSelectedPosition - mFirstPosition;</div><div class="line">                if (index &gt;= 0 &amp;&amp; index &lt; childCount) &#123;</div><div class="line">                    newSel = getChildAt(index);</div><div class="line">                &#125;</div><div class="line">                break;</div><div class="line">            case LAYOUT_FORCE_TOP:</div><div class="line">            case LAYOUT_FORCE_BOTTOM:</div><div class="line">            case LAYOUT_SPECIFIC:</div><div class="line">            case LAYOUT_SYNC:</div><div class="line">                break;</div><div class="line">            case LAYOUT_MOVE_SELECTION:</div><div class="line">            default:</div><div class="line">                // Remember the previously selected view</div><div class="line">                index = mSelectedPosition - mFirstPosition;</div><div class="line">                if (index &gt;= 0 &amp;&amp; index &lt; childCount) &#123;</div><div class="line">                    oldSel = getChildAt(index);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                // Remember the previous first child</div><div class="line">                oldFirst = getChildAt(0);</div><div class="line"></div><div class="line">                if (mNextSelectedPosition &gt;= 0) &#123;</div><div class="line">                    delta = mNextSelectedPosition - mSelectedPosition;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                // Caution: newSel might be null</div><div class="line">                newSel = getChildAt(index + delta);</div><div class="line">            &#125;</div><div class="line"></div><div class="line"></div><div class="line">            boolean dataChanged = mDataChanged;</div><div class="line">            if (dataChanged) &#123;</div><div class="line">                handleDataChanged();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // Handle the empty set by removing all views that are visible</div><div class="line">            // and calling it a day</div><div class="line">            if (mItemCount == 0) &#123;</div><div class="line">                resetList();</div><div class="line">                invokeOnItemScrollListener();</div><div class="line">                return;</div><div class="line">            &#125; else if (mItemCount != mAdapter.getCount()) &#123;</div><div class="line">                throw new IllegalStateException(&quot;The content of the adapter has changed but &quot;</div><div class="line">                        + &quot;ListView did not receive a notification. Make sure the content of &quot;</div><div class="line">                        + &quot;your adapter is not modified from a background thread, but only from &quot;</div><div class="line">                        + &quot;the UI thread. Make sure your adapter calls notifyDataSetChanged() &quot;</div><div class="line">                        + &quot;when its content changes. [in ListView(&quot; + getId() + &quot;, &quot; + getClass()</div><div class="line">                        + &quot;) with Adapter(&quot; + mAdapter.getClass() + &quot;)]&quot;);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            setSelectedPositionInt(mNextSelectedPosition);</div><div class="line"></div><div class="line">            AccessibilityNodeInfo accessibilityFocusLayoutRestoreNode = null;</div><div class="line">            View accessibilityFocusLayoutRestoreView = null;</div><div class="line">            int accessibilityFocusPosition = INVALID_POSITION;</div><div class="line"></div><div class="line">            // Remember which child, if any, had accessibility focus. This must</div><div class="line">            // occur before recycling any views, since that will clear</div><div class="line">            // accessibility focus.</div><div class="line">            final ViewRootImpl viewRootImpl = getViewRootImpl();</div><div class="line">            if (viewRootImpl != null) &#123;</div><div class="line">                final View focusHost = viewRootImpl.getAccessibilityFocusedHost();</div><div class="line">                if (focusHost != null) &#123;</div><div class="line">                    final View focusChild = getAccessibilityFocusedChild(focusHost);</div><div class="line">                    if (focusChild != null) &#123;</div><div class="line">                        if (!dataChanged || isDirectChildHeaderOrFooter(focusChild)</div><div class="line">                                || focusChild.hasTransientState() || mAdapterHasStableIds) &#123;</div><div class="line">                            // The views won&apos;t be changing, so try to maintain</div><div class="line">                            // focus on the current host and virtual view.</div><div class="line">                            accessibilityFocusLayoutRestoreView = focusHost;</div><div class="line">                            accessibilityFocusLayoutRestoreNode = viewRootImpl</div><div class="line">                                    .getAccessibilityFocusedVirtualView();</div><div class="line">                        &#125;</div><div class="line"></div><div class="line">                        // If all else fails, maintain focus at the same</div><div class="line">                        // position.</div><div class="line">                        accessibilityFocusPosition = getPositionForView(focusChild);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            View focusLayoutRestoreDirectChild = null;</div><div class="line">            View focusLayoutRestoreView = null;</div><div class="line"></div><div class="line">            // Take focus back to us temporarily to avoid the eventual call to</div><div class="line">            // clear focus when removing the focused child below from messing</div><div class="line">            // things up when ViewAncestor assigns focus back to someone else.</div><div class="line">            final View focusedChild = getFocusedChild();</div><div class="line">            if (focusedChild != null) &#123;</div><div class="line">                // TODO: in some cases focusedChild.getParent() == null</div><div class="line"></div><div class="line">                // We can remember the focused view to restore after re-layout</div><div class="line">                // if the data hasn&apos;t changed, or if the focused position is a</div><div class="line">                // header or footer.</div><div class="line">                if (!dataChanged || isDirectChildHeaderOrFooter(focusedChild)</div><div class="line">                        || focusedChild.hasTransientState() || mAdapterHasStableIds) &#123;</div><div class="line">                    focusLayoutRestoreDirectChild = focusedChild;</div><div class="line">                    // Remember the specific view that had focus.</div><div class="line">                    focusLayoutRestoreView = findFocus();</div><div class="line">                    if (focusLayoutRestoreView != null) &#123;</div><div class="line">                        // Tell it we are going to mess with it.</div><div class="line">                        focusLayoutRestoreView.dispatchStartTemporaryDetach();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                requestFocus();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // Pull all children into the RecycleBin.</div><div class="line">            // These views will be reused if possible</div><div class="line">            final int firstPosition = mFirstPosition;</div><div class="line">            final RecycleBin recycleBin = mRecycler;</div><div class="line">            if (dataChanged) &#123;</div><div class="line">                for (int i = 0; i &lt; childCount; i++) &#123;</div><div class="line">                    recycleBin.addScrapView(getChildAt(i), firstPosition+i);</div><div class="line">                &#125;</div><div class="line">            &#125; else &#123;</div><div class="line">                recycleBin.fillActiveViews(childCount, firstPosition);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // Clear out old views</div><div class="line">            detachAllViewsFromParent();</div><div class="line">            recycleBin.removeSkippedScrap();</div><div class="line"></div><div class="line">            switch (mLayoutMode) &#123;</div><div class="line">            case LAYOUT_SET_SELECTION:</div><div class="line">                if (newSel != null) &#123;</div><div class="line">                    sel = fillFromSelection(newSel.getTop(), childrenTop, childrenBottom);</div><div class="line">                &#125; else &#123;</div><div class="line">                    sel = fillFromMiddle(childrenTop, childrenBottom);</div><div class="line">                &#125;</div><div class="line">                break;</div><div class="line">            case LAYOUT_SYNC:</div><div class="line">                sel = fillSpecific(mSyncPosition, mSpecificTop);</div><div class="line">                break;</div><div class="line">            case LAYOUT_FORCE_BOTTOM:</div><div class="line">                sel = fillUp(mItemCount - 1, childrenBottom);</div><div class="line">                adjustViewsUpOrDown();</div><div class="line">                break;</div><div class="line">            case LAYOUT_FORCE_TOP:</div><div class="line">                mFirstPosition = 0;</div><div class="line">                sel = fillFromTop(childrenTop);</div><div class="line">                adjustViewsUpOrDown();</div><div class="line">                break;</div><div class="line">            case LAYOUT_SPECIFIC:</div><div class="line">                final int selectedPosition = reconcileSelectedPosition();</div><div class="line">                sel = fillSpecific(selectedPosition, mSpecificTop);</div><div class="line">                /**</div><div class="line">                 * When ListView is resized, FocusSelector requests an async selection for the</div><div class="line">                 * previously focused item to make sure it is still visible. If the item is not</div><div class="line">                 * selectable, it won&apos;t regain focus so instead we call FocusSelector</div><div class="line">                 * to directly request focus on the view after it is visible.</div><div class="line">                 */</div><div class="line">                if (sel == null &amp;&amp; mFocusSelector != null) &#123;</div><div class="line">                    final Runnable focusRunnable = mFocusSelector</div><div class="line">                            .setupFocusIfValid(selectedPosition);</div><div class="line">                    if (focusRunnable != null) &#123;</div><div class="line">                        post(focusRunnable);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                break;</div><div class="line">            case LAYOUT_MOVE_SELECTION:</div><div class="line">                sel = moveSelection(oldSel, newSel, delta, childrenTop, childrenBottom);</div><div class="line">                break;</div><div class="line">            default:</div><div class="line">                if (childCount == 0) &#123;</div><div class="line">                    if (!mStackFromBottom) &#123;</div><div class="line">                        final int position = lookForSelectablePosition(0, true);</div><div class="line">                        setSelectedPositionInt(position);</div><div class="line">                        sel = fillFromTop(childrenTop);</div><div class="line">                    &#125; else &#123;</div><div class="line">                        final int position = lookForSelectablePosition(mItemCount - 1, false);</div><div class="line">                        setSelectedPositionInt(position);</div><div class="line">                        sel = fillUp(mItemCount - 1, childrenBottom);</div><div class="line">                    &#125;</div><div class="line">                &#125; else &#123;</div><div class="line">                    if (mSelectedPosition &gt;= 0 &amp;&amp; mSelectedPosition &lt; mItemCount) &#123;</div><div class="line">                        sel = fillSpecific(mSelectedPosition,</div><div class="line">                                oldSel == null ? childrenTop : oldSel.getTop());</div><div class="line">                    &#125; else if (mFirstPosition &lt; mItemCount) &#123;</div><div class="line">                        sel = fillSpecific(mFirstPosition,</div><div class="line">                                oldFirst == null ? childrenTop : oldFirst.getTop());</div><div class="line">                    &#125; else &#123;</div><div class="line">                        sel = fillSpecific(0, childrenTop);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // Flush any cached views that did not get reused above</div><div class="line">            recycleBin.scrapActiveViews();</div><div class="line"></div><div class="line">            // remove any header/footer that has been temp detached and not re-attached</div><div class="line">            removeUnusedFixedViews(mHeaderViewInfos);</div><div class="line">            removeUnusedFixedViews(mFooterViewInfos);</div><div class="line"></div><div class="line">            if (sel != null) &#123;</div><div class="line">                // The current selected item should get focus if items are</div><div class="line">                // focusable.</div><div class="line">                if (mItemsCanFocus &amp;&amp; hasFocus() &amp;&amp; !sel.hasFocus()) &#123;</div><div class="line">                    final boolean focusWasTaken = (sel == focusLayoutRestoreDirectChild &amp;&amp;</div><div class="line">                            focusLayoutRestoreView != null &amp;&amp;</div><div class="line">                            focusLayoutRestoreView.requestFocus()) || sel.requestFocus();</div><div class="line">                    if (!focusWasTaken) &#123;</div><div class="line">                        // Selected item didn&apos;t take focus, but we still want to</div><div class="line">                        // make sure something else outside of the selected view</div><div class="line">                        // has focus.</div><div class="line">                        final View focused = getFocusedChild();</div><div class="line">                        if (focused != null) &#123;</div><div class="line">                            focused.clearFocus();</div><div class="line">                        &#125;</div><div class="line">                        positionSelector(INVALID_POSITION, sel);</div><div class="line">                    &#125; else &#123;</div><div class="line">                        sel.setSelected(false);</div><div class="line">                        mSelectorRect.setEmpty();</div><div class="line">                    &#125;</div><div class="line">                &#125; else &#123;</div><div class="line">                    positionSelector(INVALID_POSITION, sel);</div><div class="line">                &#125;</div><div class="line">                mSelectedTop = sel.getTop();</div><div class="line">            &#125; else &#123;</div><div class="line">                final boolean inTouchMode = mTouchMode == TOUCH_MODE_TAP</div><div class="line">                        || mTouchMode == TOUCH_MODE_DONE_WAITING;</div><div class="line">                if (inTouchMode) &#123;</div><div class="line">                    // If the user&apos;s finger is down, select the motion position.</div><div class="line">                    final View child = getChildAt(mMotionPosition - mFirstPosition);</div><div class="line">                    if (child != null) &#123;</div><div class="line">                        positionSelector(mMotionPosition, child);</div><div class="line">                    &#125;</div><div class="line">                &#125; else if (mSelectorPosition != INVALID_POSITION) &#123;</div><div class="line">                    // If we had previously positioned the selector somewhere,</div><div class="line">                    // put it back there. It might not match up with the data,</div><div class="line">                    // but it&apos;s transitioning out so it&apos;s not a big deal.</div><div class="line">                    final View child = getChildAt(mSelectorPosition - mFirstPosition);</div><div class="line">                    if (child != null) &#123;</div><div class="line">                        positionSelector(mSelectorPosition, child);</div><div class="line">                    &#125;</div><div class="line">                &#125; else &#123;</div><div class="line">                    // Otherwise, clear selection.</div><div class="line">                    mSelectedTop = 0;</div><div class="line">                    mSelectorRect.setEmpty();</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                // Even if there is not selected position, we may need to</div><div class="line">                // restore focus (i.e. something focusable in touch mode).</div><div class="line">                if (hasFocus() &amp;&amp; focusLayoutRestoreView != null) &#123;</div><div class="line">                    focusLayoutRestoreView.requestFocus();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // Attempt to restore accessibility focus, if necessary.</div><div class="line">            if (viewRootImpl != null) &#123;</div><div class="line">                final View newAccessibilityFocusedView = viewRootImpl.getAccessibilityFocusedHost();</div><div class="line">                if (newAccessibilityFocusedView == null) &#123;</div><div class="line">                    if (accessibilityFocusLayoutRestoreView != null</div><div class="line">                            &amp;&amp; accessibilityFocusLayoutRestoreView.isAttachedToWindow()) &#123;</div><div class="line">                        final AccessibilityNodeProvider provider =</div><div class="line">                                accessibilityFocusLayoutRestoreView.getAccessibilityNodeProvider();</div><div class="line">                        if (accessibilityFocusLayoutRestoreNode != null &amp;&amp; provider != null) &#123;</div><div class="line">                            final int virtualViewId = AccessibilityNodeInfo.getVirtualDescendantId(</div><div class="line">                                    accessibilityFocusLayoutRestoreNode.getSourceNodeId());</div><div class="line">                            provider.performAction(virtualViewId,</div><div class="line">                                    AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS, null);</div><div class="line">                        &#125; else &#123;</div><div class="line">                            accessibilityFocusLayoutRestoreView.requestAccessibilityFocus();</div><div class="line">                        &#125;</div><div class="line">                    &#125; else if (accessibilityFocusPosition != INVALID_POSITION) &#123;</div><div class="line">                        // Bound the position within the visible children.</div><div class="line">                        final int position = MathUtils.constrain(</div><div class="line">                                accessibilityFocusPosition - mFirstPosition, 0,</div><div class="line">                                getChildCount() - 1);</div><div class="line">                        final View restoreView = getChildAt(position);</div><div class="line">                        if (restoreView != null) &#123;</div><div class="line">                            restoreView.requestAccessibilityFocus();</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // Tell focus view we are done mucking with it, if it is still in</div><div class="line">            // our view hierarchy.</div><div class="line">            if (focusLayoutRestoreView != null</div><div class="line">                    &amp;&amp; focusLayoutRestoreView.getWindowToken() != null) &#123;</div><div class="line">                focusLayoutRestoreView.dispatchFinishTemporaryDetach();</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            mLayoutMode = LAYOUT_NORMAL;</div><div class="line">            mDataChanged = false;</div><div class="line">            if (mPositionScrollAfterLayout != null) &#123;</div><div class="line">                post(mPositionScrollAfterLayout);</div><div class="line">                mPositionScrollAfterLayout = null;</div><div class="line">            &#125;</div><div class="line">            mNeedSync = false;</div><div class="line">            setNextSelectedPositionInt(mSelectedPosition);</div><div class="line"></div><div class="line">            updateScrollIndicators();</div><div class="line"></div><div class="line">            if (mItemCount &gt; 0) &#123;</div><div class="line">                checkSelectionChanged();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            invokeOnItemScrollListener();</div><div class="line">        &#125; finally &#123;</div><div class="line">            if (mFocusSelector != null) &#123;</div><div class="line">                mFocusSelector.onLayoutComplete();</div><div class="line">            &#125;</div><div class="line">            if (!blockLayoutRequests) &#123;</div><div class="line">                mBlockLayoutRequests = false;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这段代码较长，我们挑重点看，首先可以确定，ListView 中没有任何子 View ，因此 getChildCount() 方法得到的值肯定是0，接着会根据 dataChanged 这个布尔值来判断执行逻辑，dataChanged 只有在数据源发生改变的时候才会变成 ture,其他情况下默认是 false,因此会调用 RecycleBin 的 fillActiveViews()  方法，调用 fillActiveViews() 方法的目的是将 ListView 中 的子 View 进行缓存，但是目前 ListView 此时并没有任何数据，因此这一行暂时不起作用。</p>
<p>接下来会根据 mLayoutMode 的值来决定布局模式，默认情况下都是普通模式 LAYOUT_NORMAL， 因此会进入 default 语句中。而下面会紧接着进行两次 if 判断，childCount 目前等于0，并且默认的布局顺序是从上而下的，因此会进入到 fillFromTop() 方法里，跟进去瞧一瞧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * Fills the list from top to bottom, starting with mFirstPosition</div><div class="line">     *</div><div class="line">     * @param nextTop The location where the top of the first item should be</div><div class="line">     *        drawn</div><div class="line">     *</div><div class="line">     * @return The view that is currently selected</div><div class="line">     */</div><div class="line">    private View fillFromTop(int nextTop) &#123;</div><div class="line">        mFirstPosition = Math.min(mFirstPosition, mSelectedPosition);</div><div class="line">        mFirstPosition = Math.min(mFirstPosition, mItemCount - 1);</div><div class="line">        if (mFirstPosition &lt; 0) &#123;</div><div class="line">            mFirstPosition = 0;</div><div class="line">        &#125;</div><div class="line">        return fillDown(mFirstPosition, nextTop);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这个方法的作用是从 mFirstPosition 开始，自顶至低取填充数据；从这个方法中，它只是简单的做了一个起始位置的判断并没有执行填充操作，因此我们有理由相信填充 ListView 的操作是在 fillDown() 方法中。跟进去瞧瞧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * Fills the list from pos down to the end of the list view.</div><div class="line">     *</div><div class="line">     * @param pos The first position to put in the list</div><div class="line">     *</div><div class="line">     * @param nextTop The location where the top of the item associated with pos</div><div class="line">     *        should be drawn</div><div class="line">     *</div><div class="line">     * @return The view that is currently selected, if it happens to be in the</div><div class="line">     *         range that we draw.</div><div class="line">     */</div><div class="line">    private View fillDown(int pos, int nextTop) &#123;</div><div class="line">        View selectedView = null;</div><div class="line"></div><div class="line">        int end = (mBottom - mTop);</div><div class="line">        if ((mGroupFlags &amp; CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) &#123;</div><div class="line">            end -= mListPadding.bottom;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        while (nextTop &lt; end &amp;&amp; pos &lt; mItemCount) &#123;</div><div class="line">            // is this the selected item?</div><div class="line">            boolean selected = pos == mSelectedPosition;</div><div class="line">            View child = makeAndAddView(pos, nextTop, true, mListPadding.left, selected);</div><div class="line"></div><div class="line">            nextTop = child.getBottom() + mDividerHeight;</div><div class="line">            if (selected) &#123;</div><div class="line">                selectedView = child;</div><div class="line">            &#125;</div><div class="line">            pos++;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        setVisibleRangeHint(mFirstPosition, mFirstPosition + getChildCount() - 1);</div><div class="line">        return selectedView;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>可以看到，这里有一个 while 循环来执行重复逻辑，这里面有几个相关值需要说明一下：</p>
<ul>
<li>nextTop 表示第一个子元素顶部距离整个 ListView 顶部的像素值。</li>
<li>pos 是传入的 mFirstPosition 值。</li>
<li>end 是 ListView 底部减去顶部所得的像素值。</li>
<li>mItemCount 是 Adapter 中的元素数量。</li>
</ul>
<p>因此在开始的时候，nextTop 必定小于 end 并且 pos 小于 mItemCount值，没执行一次 while 循环，pos 的值自动加1，并且 nextTop 也会增加，当 nextTop 大约等于 end 时，也就是子元素超出了当前屏幕，或者 pos 大于等于 mItemCount 时候，也就是说 Adapter 中所有的元素都已遍历完成。之后就会结束 while 循环。</p>
<p>在 while 循环中，真正有意义的是 makeAndAddView() 方法，追进去看一下，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * Obtains the view and adds it to our list of children. The view can be</div><div class="line">     * made fresh, converted from an unused view, or used as is if it was in</div><div class="line">     * the recycle bin.</div><div class="line">     *</div><div class="line">     * @param position logical position in the list</div><div class="line">     * @param y top or bottom edge of the view to add</div><div class="line">     * @param flow &#123;@code true&#125; to align top edge to y, &#123;@code false&#125; to align</div><div class="line">     *             bottom edge to y</div><div class="line">     * @param childrenLeft left edge where children should be positioned</div><div class="line">     * @param selected &#123;@code true&#125; if the position is selected, &#123;@code false&#125;</div><div class="line">     *                 otherwise</div><div class="line">     * @return the view that was added</div><div class="line">     */</div><div class="line">    private View makeAndAddView(int position, int y, boolean flow, int childrenLeft,</div><div class="line">            boolean selected) &#123;</div><div class="line">        if (!mDataChanged) &#123;</div><div class="line">            // Try to use an existing view for this position.</div><div class="line">            final View activeView = mRecycler.getActiveView(position);</div><div class="line">            if (activeView != null) &#123;</div><div class="line">                // Found it. We&apos;re reusing an existing child, so it just needs</div><div class="line">                // to be positioned like a scrap view.</div><div class="line">                setupChild(activeView, position, y, flow, childrenLeft, selected, true);</div><div class="line">                return activeView;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // Make a new view for this position, or convert an unused view if</div><div class="line">        // possible.</div><div class="line">        final View child = obtainView(position, mIsScrap);</div><div class="line"></div><div class="line">        // This needs to be positioned and measured.</div><div class="line">        setupChild(child, position, y, flow, childrenLeft, selected, mIsScrap[0]);</div><div class="line"></div><div class="line">        return child;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>在这个方法中首先尝试从 RecycleBin 中快速获取一个 activeView ，但是目前 RecycleBin 中还没有任何一个 View，所以这里得到的值肯定是null，那就跳出去继续执行下面语句，接下来调用 obtainView() 方法来重新获取一个 View ，这个方法会返回一个 View ，并将这个 View 传入 setupChild() 方法中；下面我们追到 obtainView() 方法中去看看，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * Gets a view and have it show the data associated with the specified</div><div class="line">     * position. This is called when we have already discovered that the view</div><div class="line">     * is not available for reuse in the recycle bin. The only choices left are</div><div class="line">     * converting an old view or making a new one.</div><div class="line">     *</div><div class="line">     * @param position the position to display</div><div class="line">     * @param outMetadata an array of at least 1 boolean where the first entry</div><div class="line">     *                    will be set &#123;@code true&#125; if the view is currently</div><div class="line">     *                    attached to the window, &#123;@code false&#125; otherwise (e.g.</div><div class="line">     *                    newly-inflated or remained scrap for multiple layout</div><div class="line">     *                    passes)</div><div class="line">     *</div><div class="line">     * @return A view displaying the data associated with the specified position</div><div class="line">     */</div><div class="line">    View obtainView(int position, boolean[] outMetadata) &#123;</div><div class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;obtainView&quot;);</div><div class="line"></div><div class="line">        outMetadata[0] = false;</div><div class="line"></div><div class="line">        // Check whether we have a transient state view. Attempt to re-bind the</div><div class="line">        // data and discard the view if we fail.</div><div class="line">        final View transientView = mRecycler.getTransientStateView(position);</div><div class="line">        if (transientView != null) &#123;</div><div class="line">            final LayoutParams params = (LayoutParams) transientView.getLayoutParams();</div><div class="line"></div><div class="line">            // If the view type hasn&apos;t changed, attempt to re-bind the data.</div><div class="line">            if (params.viewType == mAdapter.getItemViewType(position)) &#123;</div><div class="line">                final View updatedView = mAdapter.getView(position, transientView, this);</div><div class="line"></div><div class="line">                // If we failed to re-bind the data, scrap the obtained view.</div><div class="line">                if (updatedView != transientView) &#123;</div><div class="line">                    setItemViewLayoutParams(updatedView, position);</div><div class="line">                    mRecycler.addScrapView(updatedView, position);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            outMetadata[0] = true;</div><div class="line"></div><div class="line">            // Finish the temporary detach started in addScrapView().</div><div class="line">            transientView.dispatchFinishTemporaryDetach();</div><div class="line">            return transientView;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        final View scrapView = mRecycler.getScrapView(position);</div><div class="line">        final View child = mAdapter.getView(position, scrapView, this);</div><div class="line">        if (scrapView != null) &#123;</div><div class="line">            if (child != scrapView) &#123;</div><div class="line">                // Failed to re-bind the data, return scrap to the heap.</div><div class="line">                mRecycler.addScrapView(scrapView, position);</div><div class="line">            &#125; else if (child.isTemporarilyDetached()) &#123;</div><div class="line">                outMetadata[0] = true;</div><div class="line"></div><div class="line">                // Finish the temporary detach started in addScrapView().</div><div class="line">                child.dispatchFinishTemporaryDetach();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (mCacheColorHint != 0) &#123;</div><div class="line">            child.setDrawingCacheBackgroundColor(mCacheColorHint);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (child.getImportantForAccessibility() == IMPORTANT_FOR_ACCESSIBILITY_AUTO) &#123;</div><div class="line">            child.setImportantForAccessibility(IMPORTANT_FOR_ACCESSIBILITY_YES);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        setItemViewLayoutParams(child, position);</div><div class="line"></div><div class="line">        if (AccessibilityManager.getInstance(mContext).isEnabled()) &#123;</div><div class="line">            if (mAccessibilityDelegate == null) &#123;</div><div class="line">                mAccessibilityDelegate = new ListItemAccessibilityDelegate();</div><div class="line">            &#125;</div><div class="line">            if (child.getAccessibilityDelegate() == null) &#123;</div><div class="line">                child.setAccessibilityDelegate(mAccessibilityDelegate);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</div><div class="line"></div><div class="line">        return child;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>obtainView() 方法是整个 ListView 中的最重要的内容，首先调用 RecycleBin 的 getScrapView() 方法来获取一个废弃缓存的 View，因为 RecycleBin 中没有 View ，因此返回值为null，接着代码会执行 mAdapter 的 getView() 方法，是不是很熟悉，没错就是我们经常重写的方法，传入的三个参数分别为 position、 null 、this。</p>
<p>getView() 方法接收三个参数，第一个参数 position 代表当前子元素的位置，第二个元素是 convertView，由于我们传入的是null，因此 convertView 并没有用，我们会调用 LayoutInflater 的 inflate() 方法来加载一个布局，接下来会对这个 View 进行一下属性和值的设定，最后将 View 返回。</p>
<p>因此，这个 View 作为 ObtainView() 的结果返回，并传入 setupChild() 中。也就是说，第一次 layout 过程中，所有的子 View 都是通过 LayoutInflater 来加载进来的，这样相对比较耗时，但后面就不会出现这个情况啦，我们继续往下看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * Adds a view as a child and make sure it is measured (if necessary) and</div><div class="line">     * positioned properly.</div><div class="line">     *</div><div class="line">     * @param child the view to add</div><div class="line">     * @param position the position of this child</div><div class="line">     * @param y the y position relative to which this view will be positioned</div><div class="line">     * @param flowDown &#123;@code true&#125; to align top edge to y, &#123;@code false&#125; to</div><div class="line">     *                 align bottom edge to y</div><div class="line">     * @param childrenLeft left edge where children should be positioned</div><div class="line">     * @param selected &#123;@code true&#125; if the position is selected, &#123;@code false&#125;</div><div class="line">     *                 otherwise</div><div class="line">     * @param isAttachedToWindow &#123;@code true&#125; if the view is already attached</div><div class="line">     *                           to the window, e.g. whether it was reused, or</div><div class="line">     *                           &#123;@code false&#125; otherwise</div><div class="line">     */</div><div class="line">    private void setupChild(View child, int position, int y, boolean flowDown, int childrenLeft,</div><div class="line">            boolean selected, boolean isAttachedToWindow) &#123;</div><div class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;setupListItem&quot;);</div><div class="line"></div><div class="line">        final boolean isSelected = selected &amp;&amp; shouldShowSelector();</div><div class="line">        final boolean updateChildSelected = isSelected != child.isSelected();</div><div class="line">        final int mode = mTouchMode;</div><div class="line">        final boolean isPressed = mode &gt; TOUCH_MODE_DOWN &amp;&amp; mode &lt; TOUCH_MODE_SCROLL</div><div class="line">                &amp;&amp; mMotionPosition == position;</div><div class="line">        final boolean updateChildPressed = isPressed != child.isPressed();</div><div class="line">        final boolean needToMeasure = !isAttachedToWindow || updateChildSelected</div><div class="line">                || child.isLayoutRequested();</div><div class="line"></div><div class="line">        // Respect layout params that are already in the view. Otherwise make</div><div class="line">        // some up...</div><div class="line">        AbsListView.LayoutParams p = (AbsListView.LayoutParams) child.getLayoutParams();</div><div class="line">        if (p == null) &#123;</div><div class="line">            p = (AbsListView.LayoutParams) generateDefaultLayoutParams();</div><div class="line">        &#125;</div><div class="line">        p.viewType = mAdapter.getItemViewType(position);</div><div class="line">        p.isEnabled = mAdapter.isEnabled(position);</div><div class="line"></div><div class="line">        // Set up view state before attaching the view, since we may need to</div><div class="line">        // rely on the jumpDrawablesToCurrentState() call that occurs as part</div><div class="line">        // of view attachment.</div><div class="line">        if (updateChildSelected) &#123;</div><div class="line">            child.setSelected(isSelected);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (updateChildPressed) &#123;</div><div class="line">            child.setPressed(isPressed);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (mChoiceMode != CHOICE_MODE_NONE &amp;&amp; mCheckStates != null) &#123;</div><div class="line">            if (child instanceof Checkable) &#123;</div><div class="line">                ((Checkable) child).setChecked(mCheckStates.get(position));</div><div class="line">            &#125; else if (getContext().getApplicationInfo().targetSdkVersion</div><div class="line">                    &gt;= android.os.Build.VERSION_CODES.HONEYCOMB) &#123;</div><div class="line">                child.setActivated(mCheckStates.get(position));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if ((isAttachedToWindow &amp;&amp; !p.forceAdd) || (p.recycledHeaderFooter</div><div class="line">                &amp;&amp; p.viewType == AdapterView.ITEM_VIEW_TYPE_HEADER_OR_FOOTER)) &#123;</div><div class="line">            attachViewToParent(child, flowDown ? -1 : 0, p);</div><div class="line"></div><div class="line">            // If the view was previously attached for a different position,</div><div class="line">            // then manually jump the drawables.</div><div class="line">            if (isAttachedToWindow</div><div class="line">                    &amp;&amp; (((AbsListView.LayoutParams) child.getLayoutParams()).scrappedFromPosition)</div><div class="line">                            != position) &#123;</div><div class="line">                child.jumpDrawablesToCurrentState();</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            p.forceAdd = false;</div><div class="line">            if (p.viewType == AdapterView.ITEM_VIEW_TYPE_HEADER_OR_FOOTER) &#123;</div><div class="line">                p.recycledHeaderFooter = true;</div><div class="line">            &#125;</div><div class="line">            addViewInLayout(child, flowDown ? -1 : 0, p, true);</div><div class="line">            // add view in layout will reset the RTL properties. We have to re-resolve them</div><div class="line">            child.resolveRtlPropertiesIfNeeded();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (needToMeasure) &#123;</div><div class="line">            final int childWidthSpec = ViewGroup.getChildMeasureSpec(mWidthMeasureSpec,</div><div class="line">                    mListPadding.left + mListPadding.right, p.width);</div><div class="line">            final int lpHeight = p.height;</div><div class="line">            final int childHeightSpec;</div><div class="line">            if (lpHeight &gt; 0) &#123;</div><div class="line">                childHeightSpec = MeasureSpec.makeMeasureSpec(lpHeight, MeasureSpec.EXACTLY);</div><div class="line">            &#125; else &#123;</div><div class="line">                childHeightSpec = MeasureSpec.makeSafeMeasureSpec(getMeasuredHeight(),</div><div class="line">                        MeasureSpec.UNSPECIFIED);</div><div class="line">            &#125;</div><div class="line">            child.measure(childWidthSpec, childHeightSpec);</div><div class="line">        &#125; else &#123;</div><div class="line">            cleanupLayoutState(child);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        final int w = child.getMeasuredWidth();</div><div class="line">        final int h = child.getMeasuredHeight();</div><div class="line">        final int childTop = flowDown ? y : y - h;</div><div class="line"></div><div class="line">        if (needToMeasure) &#123;</div><div class="line">            final int childRight = childrenLeft + w;</div><div class="line">            final int childBottom = childTop + h;</div><div class="line">            child.layout(childrenLeft, childTop, childRight, childBottom);</div><div class="line">        &#125; else &#123;</div><div class="line">            child.offsetLeftAndRight(childrenLeft - child.getLeft());</div><div class="line">            child.offsetTopAndBottom(childTop - child.getTop());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (mCachingStarted &amp;&amp; !child.isDrawingCacheEnabled()) &#123;</div><div class="line">            child.setDrawingCacheEnabled(true);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>在这个方法中将 ObtainView() 方法获取的子元素 View ，通过调用 addViewInLayout() 方法将它添加到 ListView 当中,addViewInLayout() 方法属于 ViewGroup，作用是在 layout 中添加 View，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * Adds a view during layout. This is useful if in your onLayout() method,</div><div class="line">     * you need to add more views (as does the list view for example).</div><div class="line">     *</div><div class="line">     * If index is negative, it means put it at the end of the list.</div><div class="line">     *</div><div class="line">     * @param child the view to add to the group</div><div class="line">     * @param index the index at which the child must be added or -1 to add last</div><div class="line">     * @param params the layout parameters to associate with the child</div><div class="line">     * @param preventRequestLayout if true, calling this method will not trigger a</div><div class="line">     *        layout request on child</div><div class="line">     * @return true if the child was added, false otherwise</div><div class="line">     */</div><div class="line">    protected boolean addViewInLayout(View child, int index, LayoutParams params,</div><div class="line">            boolean preventRequestLayout) &#123;</div><div class="line">        if (child == null) &#123;</div><div class="line">            throw new IllegalArgumentException(&quot;Cannot add a null child view to a ViewGroup&quot;);</div><div class="line">        &#125;</div><div class="line">        child.mParent = null;</div><div class="line">        addViewInner(child, index, params, preventRequestLayout);</div><div class="line">        child.mPrivateFlags = (child.mPrivateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;</div><div class="line">        return true;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>那么根据 fillDown() 方法中的 while 循环，会让子元素将整个 Listview 填满。 <strong>也就是说无论我们的 Adatper 中有多少条数据，ListView 只会加载第一屏的数据，剩下的数据完全不会加载，所以不会有多余的加载工作，这样可以保证 ListView 中的内容可以迅速的展示在屏幕上。</strong></p>
<p>到此为止，第一阶段的 onLayout 过程结束。</p>
<h4 id="第二次-Layout"><a href="#第二次-Layout" class="headerlink" title="第二次 Layout"></a>第二次 Layout</h4><p>我们还是从 LayoutChildren() 方法开始：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div><div class="line">345</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">    protected void layoutChildren() &#123;</div><div class="line">        final boolean blockLayoutRequests = mBlockLayoutRequests;</div><div class="line">        if (blockLayoutRequests) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        mBlockLayoutRequests = true;</div><div class="line"></div><div class="line">        try &#123;</div><div class="line">            super.layoutChildren();</div><div class="line"></div><div class="line">            invalidate();</div><div class="line"></div><div class="line">            if (mAdapter == null) &#123;</div><div class="line">                resetList();</div><div class="line">                invokeOnItemScrollListener();</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            final int childrenTop = mListPadding.top;</div><div class="line">            final int childrenBottom = mBottom - mTop - mListPadding.bottom;</div><div class="line">            final int childCount = getChildCount();</div><div class="line"></div><div class="line">            int index = 0;</div><div class="line">            int delta = 0;</div><div class="line"></div><div class="line">            View sel;</div><div class="line">            View oldSel = null;</div><div class="line">            View oldFirst = null;</div><div class="line">            View newSel = null;</div><div class="line"></div><div class="line">            // Remember stuff we will need down below</div><div class="line">            switch (mLayoutMode) &#123;</div><div class="line">            case LAYOUT_SET_SELECTION:</div><div class="line">                index = mNextSelectedPosition - mFirstPosition;</div><div class="line">                if (index &gt;= 0 &amp;&amp; index &lt; childCount) &#123;</div><div class="line">                    newSel = getChildAt(index);</div><div class="line">                &#125;</div><div class="line">                break;</div><div class="line">            case LAYOUT_FORCE_TOP:</div><div class="line">            case LAYOUT_FORCE_BOTTOM:</div><div class="line">            case LAYOUT_SPECIFIC:</div><div class="line">            case LAYOUT_SYNC:</div><div class="line">                break;</div><div class="line">            case LAYOUT_MOVE_SELECTION:</div><div class="line">            default:</div><div class="line">                // Remember the previously selected view</div><div class="line">                index = mSelectedPosition - mFirstPosition;</div><div class="line">                if (index &gt;= 0 &amp;&amp; index &lt; childCount) &#123;</div><div class="line">                    oldSel = getChildAt(index);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                // Remember the previous first child</div><div class="line">                oldFirst = getChildAt(0);</div><div class="line"></div><div class="line">                if (mNextSelectedPosition &gt;= 0) &#123;</div><div class="line">                    delta = mNextSelectedPosition - mSelectedPosition;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                // Caution: newSel might be null</div><div class="line">                newSel = getChildAt(index + delta);</div><div class="line">            &#125;</div><div class="line"></div><div class="line"></div><div class="line">            boolean dataChanged = mDataChanged;</div><div class="line">            if (dataChanged) &#123;</div><div class="line">                handleDataChanged();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // Handle the empty set by removing all views that are visible</div><div class="line">            // and calling it a day</div><div class="line">            if (mItemCount == 0) &#123;</div><div class="line">                resetList();</div><div class="line">                invokeOnItemScrollListener();</div><div class="line">                return;</div><div class="line">            &#125; else if (mItemCount != mAdapter.getCount()) &#123;</div><div class="line">                throw new IllegalStateException(&quot;The content of the adapter has changed but &quot;</div><div class="line">                        + &quot;ListView did not receive a notification. Make sure the content of &quot;</div><div class="line">                        + &quot;your adapter is not modified from a background thread, but only from &quot;</div><div class="line">                        + &quot;the UI thread. Make sure your adapter calls notifyDataSetChanged() &quot;</div><div class="line">                        + &quot;when its content changes. [in ListView(&quot; + getId() + &quot;, &quot; + getClass()</div><div class="line">                        + &quot;) with Adapter(&quot; + mAdapter.getClass() + &quot;)]&quot;);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            setSelectedPositionInt(mNextSelectedPosition);</div><div class="line"></div><div class="line">            AccessibilityNodeInfo accessibilityFocusLayoutRestoreNode = null;</div><div class="line">            View accessibilityFocusLayoutRestoreView = null;</div><div class="line">            int accessibilityFocusPosition = INVALID_POSITION;</div><div class="line"></div><div class="line">            // Remember which child, if any, had accessibility focus. This must</div><div class="line">            // occur before recycling any views, since that will clear</div><div class="line">            // accessibility focus.</div><div class="line">            final ViewRootImpl viewRootImpl = getViewRootImpl();</div><div class="line">            if (viewRootImpl != null) &#123;</div><div class="line">                final View focusHost = viewRootImpl.getAccessibilityFocusedHost();</div><div class="line">                if (focusHost != null) &#123;</div><div class="line">                    final View focusChild = getAccessibilityFocusedChild(focusHost);</div><div class="line">                    if (focusChild != null) &#123;</div><div class="line">                        if (!dataChanged || isDirectChildHeaderOrFooter(focusChild)</div><div class="line">                                || focusChild.hasTransientState() || mAdapterHasStableIds) &#123;</div><div class="line">                            // The views won&apos;t be changing, so try to maintain</div><div class="line">                            // focus on the current host and virtual view.</div><div class="line">                            accessibilityFocusLayoutRestoreView = focusHost;</div><div class="line">                            accessibilityFocusLayoutRestoreNode = viewRootImpl</div><div class="line">                                    .getAccessibilityFocusedVirtualView();</div><div class="line">                        &#125;</div><div class="line"></div><div class="line">                        // If all else fails, maintain focus at the same</div><div class="line">                        // position.</div><div class="line">                        accessibilityFocusPosition = getPositionForView(focusChild);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            View focusLayoutRestoreDirectChild = null;</div><div class="line">            View focusLayoutRestoreView = null;</div><div class="line"></div><div class="line">            // Take focus back to us temporarily to avoid the eventual call to</div><div class="line">            // clear focus when removing the focused child below from messing</div><div class="line">            // things up when ViewAncestor assigns focus back to someone else.</div><div class="line">            final View focusedChild = getFocusedChild();</div><div class="line">            if (focusedChild != null) &#123;</div><div class="line">                // TODO: in some cases focusedChild.getParent() == null</div><div class="line"></div><div class="line">                // We can remember the focused view to restore after re-layout</div><div class="line">                // if the data hasn&apos;t changed, or if the focused position is a</div><div class="line">                // header or footer.</div><div class="line">                if (!dataChanged || isDirectChildHeaderOrFooter(focusedChild)</div><div class="line">                        || focusedChild.hasTransientState() || mAdapterHasStableIds) &#123;</div><div class="line">                    focusLayoutRestoreDirectChild = focusedChild;</div><div class="line">                    // Remember the specific view that had focus.</div><div class="line">                    focusLayoutRestoreView = findFocus();</div><div class="line">                    if (focusLayoutRestoreView != null) &#123;</div><div class="line">                        // Tell it we are going to mess with it.</div><div class="line">                        focusLayoutRestoreView.dispatchStartTemporaryDetach();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                requestFocus();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // Pull all children into the RecycleBin.</div><div class="line">            // These views will be reused if possible</div><div class="line">            final int firstPosition = mFirstPosition;</div><div class="line">            final RecycleBin recycleBin = mRecycler;</div><div class="line">            if (dataChanged) &#123;</div><div class="line">                for (int i = 0; i &lt; childCount; i++) &#123;</div><div class="line">                    recycleBin.addScrapView(getChildAt(i), firstPosition+i);</div><div class="line">                &#125;</div><div class="line">            &#125; else &#123;</div><div class="line">                recycleBin.fillActiveViews(childCount, firstPosition);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // Clear out old views</div><div class="line">            detachAllViewsFromParent();</div><div class="line">            recycleBin.removeSkippedScrap();</div><div class="line"></div><div class="line">            switch (mLayoutMode) &#123;</div><div class="line">            case LAYOUT_SET_SELECTION:</div><div class="line">                if (newSel != null) &#123;</div><div class="line">                    sel = fillFromSelection(newSel.getTop(), childrenTop, childrenBottom);</div><div class="line">                &#125; else &#123;</div><div class="line">                    sel = fillFromMiddle(childrenTop, childrenBottom);</div><div class="line">                &#125;</div><div class="line">                break;</div><div class="line">            case LAYOUT_SYNC:</div><div class="line">                sel = fillSpecific(mSyncPosition, mSpecificTop);</div><div class="line">                break;</div><div class="line">            case LAYOUT_FORCE_BOTTOM:</div><div class="line">                sel = fillUp(mItemCount - 1, childrenBottom);</div><div class="line">                adjustViewsUpOrDown();</div><div class="line">                break;</div><div class="line">            case LAYOUT_FORCE_TOP:</div><div class="line">                mFirstPosition = 0;</div><div class="line">                sel = fillFromTop(childrenTop);</div><div class="line">                adjustViewsUpOrDown();</div><div class="line">                break;</div><div class="line">            case LAYOUT_SPECIFIC:</div><div class="line">                final int selectedPosition = reconcileSelectedPosition();</div><div class="line">                sel = fillSpecific(selectedPosition, mSpecificTop);</div><div class="line">                /**</div><div class="line">                 * When ListView is resized, FocusSelector requests an async selection for the</div><div class="line">                 * previously focused item to make sure it is still visible. If the item is not</div><div class="line">                 * selectable, it won&apos;t regain focus so instead we call FocusSelector</div><div class="line">                 * to directly request focus on the view after it is visible.</div><div class="line">                 */</div><div class="line">                if (sel == null &amp;&amp; mFocusSelector != null) &#123;</div><div class="line">                    final Runnable focusRunnable = mFocusSelector</div><div class="line">                            .setupFocusIfValid(selectedPosition);</div><div class="line">                    if (focusRunnable != null) &#123;</div><div class="line">                        post(focusRunnable);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                break;</div><div class="line">            case LAYOUT_MOVE_SELECTION:</div><div class="line">                sel = moveSelection(oldSel, newSel, delta, childrenTop, childrenBottom);</div><div class="line">                break;</div><div class="line">            default:</div><div class="line">                if (childCount == 0) &#123;</div><div class="line">                    if (!mStackFromBottom) &#123;</div><div class="line">                        final int position = lookForSelectablePosition(0, true);</div><div class="line">                        setSelectedPositionInt(position);</div><div class="line">                        sel = fillFromTop(childrenTop);</div><div class="line">                    &#125; else &#123;</div><div class="line">                        final int position = lookForSelectablePosition(mItemCount - 1, false);</div><div class="line">                        setSelectedPositionInt(position);</div><div class="line">                        sel = fillUp(mItemCount - 1, childrenBottom);</div><div class="line">                    &#125;</div><div class="line">                &#125; else &#123;</div><div class="line">                    if (mSelectedPosition &gt;= 0 &amp;&amp; mSelectedPosition &lt; mItemCount) &#123;</div><div class="line">                        sel = fillSpecific(mSelectedPosition,</div><div class="line">                                oldSel == null ? childrenTop : oldSel.getTop());</div><div class="line">                    &#125; else if (mFirstPosition &lt; mItemCount) &#123;</div><div class="line">                        sel = fillSpecific(mFirstPosition,</div><div class="line">                                oldFirst == null ? childrenTop : oldFirst.getTop());</div><div class="line">                    &#125; else &#123;</div><div class="line">                        sel = fillSpecific(0, childrenTop);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // Flush any cached views that did not get reused above</div><div class="line">            recycleBin.scrapActiveViews();</div><div class="line"></div><div class="line">            // remove any header/footer that has been temp detached and not re-attached</div><div class="line">            removeUnusedFixedViews(mHeaderViewInfos);</div><div class="line">            removeUnusedFixedViews(mFooterViewInfos);</div><div class="line"></div><div class="line">            if (sel != null) &#123;</div><div class="line">                // The current selected item should get focus if items are</div><div class="line">                // focusable.</div><div class="line">                if (mItemsCanFocus &amp;&amp; hasFocus() &amp;&amp; !sel.hasFocus()) &#123;</div><div class="line">                    final boolean focusWasTaken = (sel == focusLayoutRestoreDirectChild &amp;&amp;</div><div class="line">                            focusLayoutRestoreView != null &amp;&amp;</div><div class="line">                            focusLayoutRestoreView.requestFocus()) || sel.requestFocus();</div><div class="line">                    if (!focusWasTaken) &#123;</div><div class="line">                        // Selected item didn&apos;t take focus, but we still want to</div><div class="line">                        // make sure something else outside of the selected view</div><div class="line">                        // has focus.</div><div class="line">                        final View focused = getFocusedChild();</div><div class="line">                        if (focused != null) &#123;</div><div class="line">                            focused.clearFocus();</div><div class="line">                        &#125;</div><div class="line">                        positionSelector(INVALID_POSITION, sel);</div><div class="line">                    &#125; else &#123;</div><div class="line">                        sel.setSelected(false);</div><div class="line">                        mSelectorRect.setEmpty();</div><div class="line">                    &#125;</div><div class="line">                &#125; else &#123;</div><div class="line">                    positionSelector(INVALID_POSITION, sel);</div><div class="line">                &#125;</div><div class="line">                mSelectedTop = sel.getTop();</div><div class="line">            &#125; else &#123;</div><div class="line">                final boolean inTouchMode = mTouchMode == TOUCH_MODE_TAP</div><div class="line">                        || mTouchMode == TOUCH_MODE_DONE_WAITING;</div><div class="line">                if (inTouchMode) &#123;</div><div class="line">                    // If the user&apos;s finger is down, select the motion position.</div><div class="line">                    final View child = getChildAt(mMotionPosition - mFirstPosition);</div><div class="line">                    if (child != null) &#123;</div><div class="line">                        positionSelector(mMotionPosition, child);</div><div class="line">                    &#125;</div><div class="line">                &#125; else if (mSelectorPosition != INVALID_POSITION) &#123;</div><div class="line">                    // If we had previously positioned the selector somewhere,</div><div class="line">                    // put it back there. It might not match up with the data,</div><div class="line">                    // but it&apos;s transitioning out so it&apos;s not a big deal.</div><div class="line">                    final View child = getChildAt(mSelectorPosition - mFirstPosition);</div><div class="line">                    if (child != null) &#123;</div><div class="line">                        positionSelector(mSelectorPosition, child);</div><div class="line">                    &#125;</div><div class="line">                &#125; else &#123;</div><div class="line">                    // Otherwise, clear selection.</div><div class="line">                    mSelectedTop = 0;</div><div class="line">                    mSelectorRect.setEmpty();</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                // Even if there is not selected position, we may need to</div><div class="line">                // restore focus (i.e. something focusable in touch mode).</div><div class="line">                if (hasFocus() &amp;&amp; focusLayoutRestoreView != null) &#123;</div><div class="line">                    focusLayoutRestoreView.requestFocus();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // Attempt to restore accessibility focus, if necessary.</div><div class="line">            if (viewRootImpl != null) &#123;</div><div class="line">                final View newAccessibilityFocusedView = viewRootImpl.getAccessibilityFocusedHost();</div><div class="line">                if (newAccessibilityFocusedView == null) &#123;</div><div class="line">                    if (accessibilityFocusLayoutRestoreView != null</div><div class="line">                            &amp;&amp; accessibilityFocusLayoutRestoreView.isAttachedToWindow()) &#123;</div><div class="line">                        final AccessibilityNodeProvider provider =</div><div class="line">                                accessibilityFocusLayoutRestoreView.getAccessibilityNodeProvider();</div><div class="line">                        if (accessibilityFocusLayoutRestoreNode != null &amp;&amp; provider != null) &#123;</div><div class="line">                            final int virtualViewId = AccessibilityNodeInfo.getVirtualDescendantId(</div><div class="line">                                    accessibilityFocusLayoutRestoreNode.getSourceNodeId());</div><div class="line">                            provider.performAction(virtualViewId,</div><div class="line">                                    AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS, null);</div><div class="line">                        &#125; else &#123;</div><div class="line">                            accessibilityFocusLayoutRestoreView.requestAccessibilityFocus();</div><div class="line">                        &#125;</div><div class="line">                    &#125; else if (accessibilityFocusPosition != INVALID_POSITION) &#123;</div><div class="line">                        // Bound the position within the visible children.</div><div class="line">                        final int position = MathUtils.constrain(</div><div class="line">                                accessibilityFocusPosition - mFirstPosition, 0,</div><div class="line">                                getChildCount() - 1);</div><div class="line">                        final View restoreView = getChildAt(position);</div><div class="line">                        if (restoreView != null) &#123;</div><div class="line">                            restoreView.requestAccessibilityFocus();</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // Tell focus view we are done mucking with it, if it is still in</div><div class="line">            // our view hierarchy.</div><div class="line">            if (focusLayoutRestoreView != null</div><div class="line">                    &amp;&amp; focusLayoutRestoreView.getWindowToken() != null) &#123;</div><div class="line">                focusLayoutRestoreView.dispatchFinishTemporaryDetach();</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            mLayoutMode = LAYOUT_NORMAL;</div><div class="line">            mDataChanged = false;</div><div class="line">            if (mPositionScrollAfterLayout != null) &#123;</div><div class="line">                post(mPositionScrollAfterLayout);</div><div class="line">                mPositionScrollAfterLayout = null;</div><div class="line">            &#125;</div><div class="line">            mNeedSync = false;</div><div class="line">            setNextSelectedPositionInt(mSelectedPosition);</div><div class="line"></div><div class="line">            updateScrollIndicators();</div><div class="line"></div><div class="line">            if (mItemCount &gt; 0) &#123;</div><div class="line">                checkSelectionChanged();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            invokeOnItemScrollListener();</div><div class="line">        &#125; finally &#123;</div><div class="line">            if (mFocusSelector != null) &#123;</div><div class="line">                mFocusSelector.onLayoutComplete();</div><div class="line">            &#125;</div><div class="line">            if (!blockLayoutRequests) &#123;</div><div class="line">                mBlockLayoutRequests = false;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>同样的调用 getChildCount() 方法来获取子 View 的数量，此时得到的值已经不是0了，而是一屏的 Listview 中子 view 的数量；调用 RecycleBin 的fillActiveViews() 方法，会将所有的子 view 都缓存到 RecycleBin 的 mActiveViews 数组中，后面将会用到。</p>
<p>接下来一个很重要的操作，调用 detachAllViewsFromParent() 方法，这个方法的作用是将 ListView 中所有的子 View 全部清除掉，从而保证第二次 layout 过程不会产生重复的数据。以后所有的 View 都会从 RecycleBin 的 mActiveViews 中获取。</p>
<p>接下来会进入到 mLayoutMode 的switch 判断中，走 default 情况，此时 childCount 不为0，会走到 else 里，里面有三个逻辑判断，第一个不成立，因为默认情况下我们没有选择任何子元素，mSeletedPosition 应该等于-1；第二个逻辑判断成立，那么进入到fillSpecific()方法当中，代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * Put a specific item at a specific location on the screen and then build</div><div class="line">     * up and down from there.</div><div class="line">     *</div><div class="line">     * @param position The reference view to use as the starting point</div><div class="line">     * @param top Pixel offset from the top of this view to the top of the</div><div class="line">     *        reference view.</div><div class="line">     *</div><div class="line">     * @return The selected view, or null if the selected view is outside the</div><div class="line">     *         visible area.</div><div class="line">     */</div><div class="line">    private View fillSpecific(int position, int top) &#123;</div><div class="line">        boolean tempIsSelected = position == mSelectedPosition;</div><div class="line">        View temp = makeAndAddView(position, top, true, mListPadding.left, tempIsSelected);</div><div class="line">        // Possibly changed again in fillUp if we add rows above this one.</div><div class="line">        mFirstPosition = position;</div><div class="line"></div><div class="line">        View above;</div><div class="line">        View below;</div><div class="line"></div><div class="line">        final int dividerHeight = mDividerHeight;</div><div class="line">        if (!mStackFromBottom) &#123;</div><div class="line">            above = fillUp(position - 1, temp.getTop() - dividerHeight);</div><div class="line">            // This will correct for the top of the first view not touching the top of the list</div><div class="line">            adjustViewsUpOrDown();</div><div class="line">            below = fillDown(position + 1, temp.getBottom() + dividerHeight);</div><div class="line">            int childCount = getChildCount();</div><div class="line">            if (childCount &gt; 0) &#123;</div><div class="line">                correctTooHigh(childCount);</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            below = fillDown(position + 1, temp.getBottom() + dividerHeight);</div><div class="line">            // This will correct for the bottom of the last view not touching the bottom of the list</div><div class="line">            adjustViewsUpOrDown();</div><div class="line">            above = fillUp(position - 1, temp.getTop() - dividerHeight);</div><div class="line">            int childCount = getChildCount();</div><div class="line">            if (childCount &gt; 0) &#123;</div><div class="line">                 correctTooLow(childCount);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (tempIsSelected) &#123;</div><div class="line">            return temp;</div><div class="line">        &#125; else if (above != null) &#123;</div><div class="line">            return above;</div><div class="line">        &#125; else &#123;</div><div class="line">            return below;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>fillSpecific  主要作用是 优先将指定位置的子 View 先加载到屏幕上，然后再加载该子 view 往上以及往下的其他子 View。在这个方法中再次调用了  makeAndAddView() 方法，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * Obtains the view and adds it to our list of children. The view can be</div><div class="line">     * made fresh, converted from an unused view, or used as is if it was in</div><div class="line">     * the recycle bin.</div><div class="line">     *</div><div class="line">     * @param position logical position in the list</div><div class="line">     * @param y top or bottom edge of the view to add</div><div class="line">     * @param flow &#123;@code true&#125; to align top edge to y, &#123;@code false&#125; to align</div><div class="line">     *             bottom edge to y</div><div class="line">     * @param childrenLeft left edge where children should be positioned</div><div class="line">     * @param selected &#123;@code true&#125; if the position is selected, &#123;@code false&#125;</div><div class="line">     *                 otherwise</div><div class="line">     * @return the view that was added</div><div class="line">     */</div><div class="line">    private View makeAndAddView(int position, int y, boolean flow, int childrenLeft,</div><div class="line">            boolean selected) &#123;</div><div class="line">        if (!mDataChanged) &#123;</div><div class="line">            // Try to use an existing view for this position.</div><div class="line">            final View activeView = mRecycler.getActiveView(position);</div><div class="line">            if (activeView != null) &#123;</div><div class="line">                // Found it. We&apos;re reusing an existing child, so it just needs</div><div class="line">                // to be positioned like a scrap view.</div><div class="line">                setupChild(activeView, position, y, flow, childrenLeft, selected, true);</div><div class="line">                return activeView;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // Make a new view for this position, or convert an unused view if</div><div class="line">        // possible.</div><div class="line">        final View child = obtainView(position, mIsScrap);</div><div class="line"></div><div class="line">        // This needs to be positioned and measured.</div><div class="line">        setupChild(child, position, y, flow, childrenLeft, selected, mIsScrap[0]);</div><div class="line"></div><div class="line">        return child;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>仍然是调用 RecycleBin 中的 Active View，这次active View 不为 null，因为前面我们调用了 RecycleBin 的 fillActiveViews() 方法来缓存子View。那么既然如此，就不会再进入到 obtainView() 方法，而是会直接进入 setupChild() 方法当中，这样也省去了很多时间，因为如果在  obtainView() 方法中又要去 infalte 布局的话，那么 ListView 的初始加载效率就大大降低了。</p>
<p>注意，在 setupChild() 方法中最后一个参数传入是 true，表明当前 View 是之前被回收过的，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * Adds a view as a child and make sure it is measured (if necessary) and</div><div class="line">     * positioned properly.</div><div class="line">     *</div><div class="line">     * @param child the view to add</div><div class="line">     * @param position the position of this child</div><div class="line">     * @param y the y position relative to which this view will be positioned</div><div class="line">     * @param flowDown &#123;@code true&#125; to align top edge to y, &#123;@code false&#125; to</div><div class="line">     *                 align bottom edge to y</div><div class="line">     * @param childrenLeft left edge where children should be positioned</div><div class="line">     * @param selected &#123;@code true&#125; if the position is selected, &#123;@code false&#125;</div><div class="line">     *                 otherwise</div><div class="line">     * @param isAttachedToWindow &#123;@code true&#125; if the view is already attached</div><div class="line">     *                           to the window, e.g. whether it was reused, or</div><div class="line">     *                           &#123;@code false&#125; otherwise</div><div class="line">     */</div><div class="line">    private void setupChild(View child, int position, int y, boolean flowDown, int childrenLeft,</div><div class="line">            boolean selected, boolean isAttachedToWindow) &#123;</div><div class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;setupListItem&quot;);</div><div class="line"></div><div class="line">        final boolean isSelected = selected &amp;&amp; shouldShowSelector();</div><div class="line">        final boolean updateChildSelected = isSelected != child.isSelected();</div><div class="line">        final int mode = mTouchMode;</div><div class="line">        final boolean isPressed = mode &gt; TOUCH_MODE_DOWN &amp;&amp; mode &lt; TOUCH_MODE_SCROLL</div><div class="line">                &amp;&amp; mMotionPosition == position;</div><div class="line">        final boolean updateChildPressed = isPressed != child.isPressed();</div><div class="line">        final boolean needToMeasure = !isAttachedToWindow || updateChildSelected</div><div class="line">                || child.isLayoutRequested();</div><div class="line"></div><div class="line">        // Respect layout params that are already in the view. Otherwise make</div><div class="line">        // some up...</div><div class="line">        AbsListView.LayoutParams p = (AbsListView.LayoutParams) child.getLayoutParams();</div><div class="line">        if (p == null) &#123;</div><div class="line">            p = (AbsListView.LayoutParams) generateDefaultLayoutParams();</div><div class="line">        &#125;</div><div class="line">        p.viewType = mAdapter.getItemViewType(position);</div><div class="line">        p.isEnabled = mAdapter.isEnabled(position);</div><div class="line"></div><div class="line">        // Set up view state before attaching the view, since we may need to</div><div class="line">        // rely on the jumpDrawablesToCurrentState() call that occurs as part</div><div class="line">        // of view attachment.</div><div class="line">        if (updateChildSelected) &#123;</div><div class="line">            child.setSelected(isSelected);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (updateChildPressed) &#123;</div><div class="line">            child.setPressed(isPressed);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (mChoiceMode != CHOICE_MODE_NONE &amp;&amp; mCheckStates != null) &#123;</div><div class="line">            if (child instanceof Checkable) &#123;</div><div class="line">                ((Checkable) child).setChecked(mCheckStates.get(position));</div><div class="line">            &#125; else if (getContext().getApplicationInfo().targetSdkVersion</div><div class="line">                    &gt;= android.os.Build.VERSION_CODES.HONEYCOMB) &#123;</div><div class="line">                child.setActivated(mCheckStates.get(position));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if ((isAttachedToWindow &amp;&amp; !p.forceAdd) || (p.recycledHeaderFooter</div><div class="line">                &amp;&amp; p.viewType == AdapterView.ITEM_VIEW_TYPE_HEADER_OR_FOOTER)) &#123;</div><div class="line">            attachViewToParent(child, flowDown ? -1 : 0, p);</div><div class="line"></div><div class="line">            // If the view was previously attached for a different position,</div><div class="line">            // then manually jump the drawables.</div><div class="line">            if (isAttachedToWindow</div><div class="line">                    &amp;&amp; (((AbsListView.LayoutParams) child.getLayoutParams()).scrappedFromPosition)</div><div class="line">                            != position) &#123;</div><div class="line">                child.jumpDrawablesToCurrentState();</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            p.forceAdd = false;</div><div class="line">            if (p.viewType == AdapterView.ITEM_VIEW_TYPE_HEADER_OR_FOOTER) &#123;</div><div class="line">                p.recycledHeaderFooter = true;</div><div class="line">            &#125;</div><div class="line">            addViewInLayout(child, flowDown ? -1 : 0, p, true);</div><div class="line">            // add view in layout will reset the RTL properties. We have to re-resolve them</div><div class="line">            child.resolveRtlPropertiesIfNeeded();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (needToMeasure) &#123;</div><div class="line">            final int childWidthSpec = ViewGroup.getChildMeasureSpec(mWidthMeasureSpec,</div><div class="line">                    mListPadding.left + mListPadding.right, p.width);</div><div class="line">            final int lpHeight = p.height;</div><div class="line">            final int childHeightSpec;</div><div class="line">            if (lpHeight &gt; 0) &#123;</div><div class="line">                childHeightSpec = MeasureSpec.makeMeasureSpec(lpHeight, MeasureSpec.EXACTLY);</div><div class="line">            &#125; else &#123;</div><div class="line">                childHeightSpec = MeasureSpec.makeSafeMeasureSpec(getMeasuredHeight(),</div><div class="line">                        MeasureSpec.UNSPECIFIED);</div><div class="line">            &#125;</div><div class="line">            child.measure(childWidthSpec, childHeightSpec);</div><div class="line">        &#125; else &#123;</div><div class="line">            cleanupLayoutState(child);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        final int w = child.getMeasuredWidth();</div><div class="line">        final int h = child.getMeasuredHeight();</div><div class="line">        final int childTop = flowDown ? y : y - h;</div><div class="line"></div><div class="line">        if (needToMeasure) &#123;</div><div class="line">            final int childRight = childrenLeft + w;</div><div class="line">            final int childBottom = childTop + h;</div><div class="line">            child.layout(childrenLeft, childTop, childRight, childBottom);</div><div class="line">        &#125; else &#123;</div><div class="line">            child.offsetLeftAndRight(childrenLeft - child.getLeft());</div><div class="line">            child.offsetTopAndBottom(childTop - child.getTop());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (mCachingStarted &amp;&amp; !child.isDrawingCacheEnabled()) &#123;</div><div class="line">            child.setDrawingCacheEnabled(true);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>可以看到 ，setupChild() 方法的最后一个参数是 isAttachedToWindow，在接下来的代码中，对这个变量进行判断，会调用 attchViewToParent()方法，我们第一次调用的方法是 addViewInLayout()。这个两个方法的最大区别在于：</p>
<ul>
<li>如果向 ViewGroup 中添加一个新的子 View ，应该调用 addViewInLayout() 方法；</li>
<li>如果想要将一个之前的 detach 的View 重新 attach 到 ViewGroup 上，应该调用 attachViewToParent() 方法。</li>
</ul>
<p>前面在 layoutChildren() 方法当中调用了 detachAllViewsFromParent()  方法，这样ListView中所有的子 View 都是处于 detach 状态的，所以这里 attachViewToParent() 方法是正确的选择。</p>
<p>到此为止，第二次 Layout 结束。</p>
<h4 id="滑动加载更多数据"><a href="#滑动加载更多数据" class="headerlink" title="滑动加载更多数据"></a>滑动加载更多数据</h4><p>由于滑动机制属于通用的，我们去 AbsListView 的 onTouchEvent() 方法中去一探究竟，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">    public boolean onTouchEvent(MotionEvent ev) &#123;</div><div class="line">        if (!isEnabled()) &#123;</div><div class="line">            // A disabled view that is clickable still consumes the touch</div><div class="line">            // events, it just doesn&apos;t respond to them.</div><div class="line">            return isClickable() || isLongClickable();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (mPositionScroller != null) &#123;</div><div class="line">            mPositionScroller.stop();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (mIsDetaching || !isAttachedToWindow()) &#123;</div><div class="line">            // Something isn&apos;t right.</div><div class="line">            // Since we rely on being attached to get data set change notifications,</div><div class="line">            // don&apos;t risk doing anything where we might try to resync and find things</div><div class="line">            // in a bogus state.</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        startNestedScroll(SCROLL_AXIS_VERTICAL);</div><div class="line"></div><div class="line">        if (mFastScroll != null &amp;&amp; mFastScroll.onTouchEvent(ev)) &#123;</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        initVelocityTrackerIfNotExists();</div><div class="line">        final MotionEvent vtev = MotionEvent.obtain(ev);</div><div class="line"></div><div class="line">        final int actionMasked = ev.getActionMasked();</div><div class="line">        if (actionMasked == MotionEvent.ACTION_DOWN) &#123;</div><div class="line">            mNestedYOffset = 0;</div><div class="line">        &#125;</div><div class="line">        vtev.offsetLocation(0, mNestedYOffset);</div><div class="line">        switch (actionMasked) &#123;</div><div class="line">            case MotionEvent.ACTION_DOWN: &#123;</div><div class="line">                onTouchDown(ev);</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            case MotionEvent.ACTION_MOVE: &#123;</div><div class="line">                onTouchMove(ev, vtev);</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            case MotionEvent.ACTION_UP: &#123;</div><div class="line">                onTouchUp(ev);</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            case MotionEvent.ACTION_CANCEL: &#123;</div><div class="line">                onTouchCancel();</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            case MotionEvent.ACTION_POINTER_UP: &#123;</div><div class="line">                onSecondaryPointerUp(ev);</div><div class="line">                final int x = mMotionX;</div><div class="line">                final int y = mMotionY;</div><div class="line">                final int motionPosition = pointToPosition(x, y);</div><div class="line">                if (motionPosition &gt;= 0) &#123;</div><div class="line">                    // Remember where the motion event started</div><div class="line">                    final View child = getChildAt(motionPosition - mFirstPosition);</div><div class="line">                    mMotionViewOriginalTop = child.getTop();</div><div class="line">                    mMotionPosition = motionPosition;</div><div class="line">                &#125;</div><div class="line">                mLastY = y;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            case MotionEvent.ACTION_POINTER_DOWN: &#123;</div><div class="line">                // New pointers take over dragging duties</div><div class="line">                final int index = ev.getActionIndex();</div><div class="line">                final int id = ev.getPointerId(index);</div><div class="line">                final int x = (int) ev.getX(index);</div><div class="line">                final int y = (int) ev.getY(index);</div><div class="line">                mMotionCorrection = 0;</div><div class="line">                mActivePointerId = id;</div><div class="line">                mMotionX = x;</div><div class="line">                mMotionY = y;</div><div class="line">                final int motionPosition = pointToPosition(x, y);</div><div class="line">                if (motionPosition &gt;= 0) &#123;</div><div class="line">                    // Remember where the motion event started</div><div class="line">                    final View child = getChildAt(motionPosition - mFirstPosition);</div><div class="line">                    mMotionViewOriginalTop = child.getTop();</div><div class="line">                    mMotionPosition = motionPosition;</div><div class="line">                &#125;</div><div class="line">                mLastY = y;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (mVelocityTracker != null) &#123;</div><div class="line">            mVelocityTracker.addMovement(vtev);</div><div class="line">        &#125;</div><div class="line">        vtev.recycle();</div><div class="line">        return true;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">private void onTouchMove(MotionEvent ev, MotionEvent vtev) &#123;</div><div class="line">        if (mHasPerformedLongPress) &#123;</div><div class="line">            // Consume all move events following a successful long press.</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        int pointerIndex = ev.findPointerIndex(mActivePointerId);</div><div class="line">        if (pointerIndex == -1) &#123;</div><div class="line">            pointerIndex = 0;</div><div class="line">            mActivePointerId = ev.getPointerId(pointerIndex);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (mDataChanged) &#123;</div><div class="line">            // Re-sync everything if data has been changed</div><div class="line">            // since the scroll operation can query the adapter.</div><div class="line">            layoutChildren();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        final int y = (int) ev.getY(pointerIndex);</div><div class="line"></div><div class="line">        switch (mTouchMode) &#123;</div><div class="line">            case TOUCH_MODE_DOWN:</div><div class="line">            case TOUCH_MODE_TAP:</div><div class="line">            case TOUCH_MODE_DONE_WAITING:</div><div class="line">                // Check if we have moved far enough that it looks more like a</div><div class="line">                // scroll than a tap. If so, we&apos;ll enter scrolling mode.</div><div class="line">                if (startScrollIfNeeded((int) ev.getX(pointerIndex), y, vtev)) &#123;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">                // Otherwise, check containment within list bounds. If we&apos;re</div><div class="line">                // outside bounds, cancel any active presses.</div><div class="line">                final View motionView = getChildAt(mMotionPosition - mFirstPosition);</div><div class="line">                final float x = ev.getX(pointerIndex);</div><div class="line">                if (!pointInView(x, y, mTouchSlop)) &#123;</div><div class="line">                    setPressed(false);</div><div class="line">                    if (motionView != null) &#123;</div><div class="line">                        motionView.setPressed(false);</div><div class="line">                    &#125;</div><div class="line">                    removeCallbacks(mTouchMode == TOUCH_MODE_DOWN ?</div><div class="line">                            mPendingCheckForTap : mPendingCheckForLongPress);</div><div class="line">                    mTouchMode = TOUCH_MODE_DONE_WAITING;</div><div class="line">                    updateSelectorState();</div><div class="line">                &#125; else if (motionView != null) &#123;</div><div class="line">                    // Still within bounds, update the hotspot.</div><div class="line">                    final float[] point = mTmpPoint;</div><div class="line">                    point[0] = x;</div><div class="line">                    point[1] = y;</div><div class="line">                    transformPointToViewLocal(point, motionView);</div><div class="line">                    motionView.drawableHotspotChanged(point[0], point[1]);</div><div class="line">                &#125;</div><div class="line">                break;</div><div class="line">            case TOUCH_MODE_SCROLL:</div><div class="line">            case TOUCH_MODE_OVERSCROLL:</div><div class="line">                scrollIfNeeded((int) ev.getX(pointerIndex), y, vtev);</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>手指在屏幕上滑动时，TouchMode 是 TOUCH_HOME_SCROLL 这个值，因此继续寻找，进入 scrollIfNeeded() 方法，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div></pre></td><td class="code"><pre><div class="line">private void scrollIfNeeded(int x, int y, MotionEvent vtev) &#123;</div><div class="line">        int rawDeltaY = y - mMotionY;</div><div class="line">        int scrollOffsetCorrection = 0;</div><div class="line">        int scrollConsumedCorrection = 0;</div><div class="line">        if (mLastY == Integer.MIN_VALUE) &#123;</div><div class="line">            rawDeltaY -= mMotionCorrection;</div><div class="line">        &#125;</div><div class="line">        if (dispatchNestedPreScroll(0, mLastY != Integer.MIN_VALUE ? mLastY - y : -rawDeltaY,</div><div class="line">                mScrollConsumed, mScrollOffset)) &#123;</div><div class="line">            rawDeltaY += mScrollConsumed[1];</div><div class="line">            scrollOffsetCorrection = -mScrollOffset[1];</div><div class="line">            scrollConsumedCorrection = mScrollConsumed[1];</div><div class="line">            if (vtev != null) &#123;</div><div class="line">                vtev.offsetLocation(0, mScrollOffset[1]);</div><div class="line">                mNestedYOffset += mScrollOffset[1];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        final int deltaY = rawDeltaY;</div><div class="line">        int incrementalDeltaY =</div><div class="line">                mLastY != Integer.MIN_VALUE ? y - mLastY + scrollConsumedCorrection : deltaY;</div><div class="line">        int lastYCorrection = 0;</div><div class="line"></div><div class="line">        if (mTouchMode == TOUCH_MODE_SCROLL) &#123;</div><div class="line">            if (PROFILE_SCROLLING) &#123;</div><div class="line">                if (!mScrollProfilingStarted) &#123;</div><div class="line">                    Debug.startMethodTracing(&quot;AbsListViewScroll&quot;);</div><div class="line">                    mScrollProfilingStarted = true;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (mScrollStrictSpan == null) &#123;</div><div class="line">                // If it&apos;s non-null, we&apos;re already in a scroll.</div><div class="line">                mScrollStrictSpan = StrictMode.enterCriticalSpan(&quot;AbsListView-scroll&quot;);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (y != mLastY) &#123;</div><div class="line">                // We may be here after stopping a fling and continuing to scroll.</div><div class="line">                // If so, we haven&apos;t disallowed intercepting touch events yet.</div><div class="line">                // Make sure that we do so in case we&apos;re in a parent that can intercept.</div><div class="line">                if ((mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) == 0 &amp;&amp;</div><div class="line">                        Math.abs(rawDeltaY) &gt; mTouchSlop) &#123;</div><div class="line">                    final ViewParent parent = getParent();</div><div class="line">                    if (parent != null) &#123;</div><div class="line">                        parent.requestDisallowInterceptTouchEvent(true);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                final int motionIndex;</div><div class="line">                if (mMotionPosition &gt;= 0) &#123;</div><div class="line">                    motionIndex = mMotionPosition - mFirstPosition;</div><div class="line">                &#125; else &#123;</div><div class="line">                    // If we don&apos;t have a motion position that we can reliably track,</div><div class="line">                    // pick something in the middle to make a best guess at things below.</div><div class="line">                    motionIndex = getChildCount() / 2;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                int motionViewPrevTop = 0;</div><div class="line">                View motionView = this.getChildAt(motionIndex);</div><div class="line">                if (motionView != null) &#123;</div><div class="line">                    motionViewPrevTop = motionView.getTop();</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                // No need to do all this work if we&apos;re not going to move anyway</div><div class="line">                boolean atEdge = false;</div><div class="line">                if (incrementalDeltaY != 0) &#123;</div><div class="line">                    atEdge = trackMotionScroll(deltaY, incrementalDeltaY);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                // Check to see if we have bumped into the scroll limit</div><div class="line">                motionView = this.getChildAt(motionIndex);</div><div class="line">                if (motionView != null) &#123;</div><div class="line">                    // Check if the top of the motion view is where it is</div><div class="line">                    // supposed to be</div><div class="line">                    final int motionViewRealTop = motionView.getTop();</div><div class="line">                    if (atEdge) &#123;</div><div class="line">                        // Apply overscroll</div><div class="line"></div><div class="line">                        int overscroll = -incrementalDeltaY -</div><div class="line">                                (motionViewRealTop - motionViewPrevTop);</div><div class="line">                        if (dispatchNestedScroll(0, overscroll - incrementalDeltaY, 0, overscroll,</div><div class="line">                                mScrollOffset)) &#123;</div><div class="line">                            lastYCorrection -= mScrollOffset[1];</div><div class="line">                            if (vtev != null) &#123;</div><div class="line">                                vtev.offsetLocation(0, mScrollOffset[1]);</div><div class="line">                                mNestedYOffset += mScrollOffset[1];</div><div class="line">                            &#125;</div><div class="line">                        &#125; else &#123;</div><div class="line">                            final boolean atOverscrollEdge = overScrollBy(0, overscroll,</div><div class="line">                                    0, mScrollY, 0, 0, 0, mOverscrollDistance, true);</div><div class="line"></div><div class="line">                            if (atOverscrollEdge &amp;&amp; mVelocityTracker != null) &#123;</div><div class="line">                                // Don&apos;t allow overfling if we&apos;re at the edge</div><div class="line">                                mVelocityTracker.clear();</div><div class="line">                            &#125;</div><div class="line"></div><div class="line">                            final int overscrollMode = getOverScrollMode();</div><div class="line">                            if (overscrollMode == OVER_SCROLL_ALWAYS ||</div><div class="line">                                    (overscrollMode == OVER_SCROLL_IF_CONTENT_SCROLLS &amp;&amp;</div><div class="line">                                            !contentFits())) &#123;</div><div class="line">                                if (!atOverscrollEdge) &#123;</div><div class="line">                                    mDirection = 0; // Reset when entering overscroll.</div><div class="line">                                    mTouchMode = TOUCH_MODE_OVERSCROLL;</div><div class="line">                                &#125;</div><div class="line">                                if (incrementalDeltaY &gt; 0) &#123;</div><div class="line">                                    mEdgeGlowTop.onPull((float) -overscroll / getHeight(),</div><div class="line">                                            (float) x / getWidth());</div><div class="line">                                    if (!mEdgeGlowBottom.isFinished()) &#123;</div><div class="line">                                        mEdgeGlowBottom.onRelease();</div><div class="line">                                    &#125;</div><div class="line">                                    invalidateTopGlow();</div><div class="line">                                &#125; else if (incrementalDeltaY &lt; 0) &#123;</div><div class="line">                                    mEdgeGlowBottom.onPull((float) overscroll / getHeight(),</div><div class="line">                                            1.f - (float) x / getWidth());</div><div class="line">                                    if (!mEdgeGlowTop.isFinished()) &#123;</div><div class="line">                                        mEdgeGlowTop.onRelease();</div><div class="line">                                    &#125;</div><div class="line">                                    invalidateBottomGlow();</div><div class="line">                                &#125;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    mMotionY = y + lastYCorrection + scrollOffsetCorrection;</div><div class="line">                &#125;</div><div class="line">                mLastY = y + lastYCorrection + scrollOffsetCorrection;</div><div class="line">            &#125;</div><div class="line">        &#125; else if (mTouchMode == TOUCH_MODE_OVERSCROLL) &#123;</div><div class="line">            if (y != mLastY) &#123;</div><div class="line">                final int oldScroll = mScrollY;</div><div class="line">                final int newScroll = oldScroll - incrementalDeltaY;</div><div class="line">                int newDirection = y &gt; mLastY ? 1 : -1;</div><div class="line"></div><div class="line">                if (mDirection == 0) &#123;</div><div class="line">                    mDirection = newDirection;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                int overScrollDistance = -incrementalDeltaY;</div><div class="line">                if ((newScroll &lt; 0 &amp;&amp; oldScroll &gt;= 0) || (newScroll &gt; 0 &amp;&amp; oldScroll &lt;= 0)) &#123;</div><div class="line">                    overScrollDistance = -oldScroll;</div><div class="line">                    incrementalDeltaY += overScrollDistance;</div><div class="line">                &#125; else &#123;</div><div class="line">                    incrementalDeltaY = 0;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                if (overScrollDistance != 0) &#123;</div><div class="line">                    overScrollBy(0, overScrollDistance, 0, mScrollY, 0, 0,</div><div class="line">                            0, mOverscrollDistance, true);</div><div class="line">                    final int overscrollMode = getOverScrollMode();</div><div class="line">                    if (overscrollMode == OVER_SCROLL_ALWAYS ||</div><div class="line">                            (overscrollMode == OVER_SCROLL_IF_CONTENT_SCROLLS &amp;&amp;</div><div class="line">                                    !contentFits())) &#123;</div><div class="line">                        if (rawDeltaY &gt; 0) &#123;</div><div class="line">                            mEdgeGlowTop.onPull((float) overScrollDistance / getHeight(),</div><div class="line">                                    (float) x / getWidth());</div><div class="line">                            if (!mEdgeGlowBottom.isFinished()) &#123;</div><div class="line">                                mEdgeGlowBottom.onRelease();</div><div class="line">                            &#125;</div><div class="line">                            invalidateTopGlow();</div><div class="line">                        &#125; else if (rawDeltaY &lt; 0) &#123;</div><div class="line">                            mEdgeGlowBottom.onPull((float) overScrollDistance / getHeight(),</div><div class="line">                                    1.f - (float) x / getWidth());</div><div class="line">                            if (!mEdgeGlowTop.isFinished()) &#123;</div><div class="line">                                mEdgeGlowTop.onRelease();</div><div class="line">                            &#125;</div><div class="line">                            invalidateBottomGlow();</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                if (incrementalDeltaY != 0) &#123;</div><div class="line">                    // Coming back to &apos;real&apos; list scrolling</div><div class="line">                    if (mScrollY != 0) &#123;</div><div class="line">                        mScrollY = 0;</div><div class="line">                        invalidateParentIfNeeded();</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    trackMotionScroll(incrementalDeltaY, incrementalDeltaY);</div><div class="line"></div><div class="line">                    mTouchMode = TOUCH_MODE_SCROLL;</div><div class="line"></div><div class="line">                    // We did not scroll the full amount. Treat this essentially like the</div><div class="line">                    // start of a new touch scroll</div><div class="line">                    final int motionPosition = findClosestMotionRow(y);</div><div class="line"></div><div class="line">                    mMotionCorrection = 0;</div><div class="line">                    View motionView = getChildAt(motionPosition - mFirstPosition);</div><div class="line">                    mMotionViewOriginalTop = motionView != null ? motionView.getTop() : 0;</div><div class="line">                    mMotionY =  y + scrollOffsetCorrection;</div><div class="line">                    mMotionPosition = motionPosition;</div><div class="line">                &#125;</div><div class="line">                mLastY = y + lastYCorrection + scrollOffsetCorrection;</div><div class="line">                mDirection = newDirection;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>调用 trackMotionScroll() 方法，只要我们的手指在屏幕上稍微有一点点移动，这个方法就会被调用多次，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * Track a motion scroll</div><div class="line">     *</div><div class="line">     * @param deltaY Amount to offset mMotionView. This is the accumulated delta since the motion</div><div class="line">     *        began. Positive numbers mean the user&apos;s finger is moving down the screen.</div><div class="line">     * @param incrementalDeltaY Change in deltaY from the previous event.</div><div class="line">     * @return true if we&apos;re already at the beginning/end of the list and have nothing to do.</div><div class="line">     */</div><div class="line">    boolean trackMotionScroll(int deltaY, int incrementalDeltaY) &#123;</div><div class="line">        final int childCount = getChildCount();</div><div class="line">        if (childCount == 0) &#123;</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        final int firstTop = getChildAt(0).getTop();</div><div class="line">        final int lastBottom = getChildAt(childCount - 1).getBottom();</div><div class="line"></div><div class="line">        final Rect listPadding = mListPadding;</div><div class="line"></div><div class="line">        // &quot;effective padding&quot; In this case is the amount of padding that affects</div><div class="line">        // how much space should not be filled by items. If we don&apos;t clip to padding</div><div class="line">        // there is no effective padding.</div><div class="line">        int effectivePaddingTop = 0;</div><div class="line">        int effectivePaddingBottom = 0;</div><div class="line">        if ((mGroupFlags &amp; CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) &#123;</div><div class="line">            effectivePaddingTop = listPadding.top;</div><div class="line">            effectivePaddingBottom = listPadding.bottom;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">         // FIXME account for grid vertical spacing too?</div><div class="line">        final int spaceAbove = effectivePaddingTop - firstTop;</div><div class="line">        final int end = getHeight() - effectivePaddingBottom;</div><div class="line">        final int spaceBelow = lastBottom - end;</div><div class="line"></div><div class="line">        final int height = getHeight() - mPaddingBottom - mPaddingTop;</div><div class="line">        if (deltaY &lt; 0) &#123;</div><div class="line">            deltaY = Math.max(-(height - 1), deltaY);</div><div class="line">        &#125; else &#123;</div><div class="line">            deltaY = Math.min(height - 1, deltaY);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (incrementalDeltaY &lt; 0) &#123;</div><div class="line">            incrementalDeltaY = Math.max(-(height - 1), incrementalDeltaY);</div><div class="line">        &#125; else &#123;</div><div class="line">            incrementalDeltaY = Math.min(height - 1, incrementalDeltaY);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        final int firstPosition = mFirstPosition;</div><div class="line"></div><div class="line">        // Update our guesses for where the first and last views are</div><div class="line">        if (firstPosition == 0) &#123;</div><div class="line">            mFirstPositionDistanceGuess = firstTop - listPadding.top;</div><div class="line">        &#125; else &#123;</div><div class="line">            mFirstPositionDistanceGuess += incrementalDeltaY;</div><div class="line">        &#125;</div><div class="line">        if (firstPosition + childCount == mItemCount) &#123;</div><div class="line">            mLastPositionDistanceGuess = lastBottom + listPadding.bottom;</div><div class="line">        &#125; else &#123;</div><div class="line">            mLastPositionDistanceGuess += incrementalDeltaY;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        final boolean cannotScrollDown = (firstPosition == 0 &amp;&amp;</div><div class="line">                firstTop &gt;= listPadding.top &amp;&amp; incrementalDeltaY &gt;= 0);</div><div class="line">        final boolean cannotScrollUp = (firstPosition + childCount == mItemCount &amp;&amp;</div><div class="line">                lastBottom &lt;= getHeight() - listPadding.bottom &amp;&amp; incrementalDeltaY &lt;= 0);</div><div class="line"></div><div class="line">        if (cannotScrollDown || cannotScrollUp) &#123;</div><div class="line">            return incrementalDeltaY != 0;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        final boolean down = incrementalDeltaY &lt; 0;</div><div class="line"></div><div class="line">        final boolean inTouchMode = isInTouchMode();</div><div class="line">        if (inTouchMode) &#123;</div><div class="line">            hideSelector();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        final int headerViewsCount = getHeaderViewsCount();</div><div class="line">        final int footerViewsStart = mItemCount - getFooterViewsCount();</div><div class="line"></div><div class="line">        int start = 0;</div><div class="line">        int count = 0;</div><div class="line"></div><div class="line">        if (down) &#123;</div><div class="line">            int top = -incrementalDeltaY;</div><div class="line">            if ((mGroupFlags &amp; CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) &#123;</div><div class="line">                top += listPadding.top;</div><div class="line">            &#125;</div><div class="line">            for (int i = 0; i &lt; childCount; i++) &#123;</div><div class="line">                final View child = getChildAt(i);</div><div class="line">                if (child.getBottom() &gt;= top) &#123;</div><div class="line">                    break;</div><div class="line">                &#125; else &#123;</div><div class="line">                    count++;</div><div class="line">                    int position = firstPosition + i;</div><div class="line">                    if (position &gt;= headerViewsCount &amp;&amp; position &lt; footerViewsStart) &#123;</div><div class="line">                        // The view will be rebound to new data, clear any</div><div class="line">                        // system-managed transient state.</div><div class="line">                        child.clearAccessibilityFocus();</div><div class="line">                        mRecycler.addScrapView(child, position);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            int bottom = getHeight() - incrementalDeltaY;</div><div class="line">            if ((mGroupFlags &amp; CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) &#123;</div><div class="line">                bottom -= listPadding.bottom;</div><div class="line">            &#125;</div><div class="line">            for (int i = childCount - 1; i &gt;= 0; i--) &#123;</div><div class="line">                final View child = getChildAt(i);</div><div class="line">                if (child.getTop() &lt;= bottom) &#123;</div><div class="line">                    break;</div><div class="line">                &#125; else &#123;</div><div class="line">                    start = i;</div><div class="line">                    count++;</div><div class="line">                    int position = firstPosition + i;</div><div class="line">                    if (position &gt;= headerViewsCount &amp;&amp; position &lt; footerViewsStart) &#123;</div><div class="line">                        // The view will be rebound to new data, clear any</div><div class="line">                        // system-managed transient state.</div><div class="line">                        child.clearAccessibilityFocus();</div><div class="line">                        mRecycler.addScrapView(child, position);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        mMotionViewNewTop = mMotionViewOriginalTop + deltaY;</div><div class="line"></div><div class="line">        mBlockLayoutRequests = true;</div><div class="line"></div><div class="line">        if (count &gt; 0) &#123;</div><div class="line">            detachViewsFromParent(start, count);</div><div class="line">            mRecycler.removeSkippedScrap();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // invalidate before moving the children to avoid unnecessary invalidate</div><div class="line">        // calls to bubble up from the children all the way to the top</div><div class="line">        if (!awakenScrollBars()) &#123;</div><div class="line">           invalidate();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        offsetChildrenTopAndBottom(incrementalDeltaY);</div><div class="line"></div><div class="line">        if (down) &#123;</div><div class="line">            mFirstPosition += count;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        final int absIncrementalDeltaY = Math.abs(incrementalDeltaY);</div><div class="line">        if (spaceAbove &lt; absIncrementalDeltaY || spaceBelow &lt; absIncrementalDeltaY) &#123;</div><div class="line">            fillGap(down);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        mRecycler.fullyDetachScrapViews();</div><div class="line">        if (!inTouchMode &amp;&amp; mSelectedPosition != INVALID_POSITION) &#123;</div><div class="line">            final int childIndex = mSelectedPosition - mFirstPosition;</div><div class="line">            if (childIndex &gt;= 0 &amp;&amp; childIndex &lt; getChildCount()) &#123;</div><div class="line">                positionSelector(mSelectedPosition, getChildAt(childIndex));</div><div class="line">            &#125;</div><div class="line">        &#125; else if (mSelectorPosition != INVALID_POSITION) &#123;</div><div class="line">            final int childIndex = mSelectorPosition - mFirstPosition;</div><div class="line">            if (childIndex &gt;= 0 &amp;&amp; childIndex &lt; getChildCount()) &#123;</div><div class="line">                positionSelector(INVALID_POSITION, getChildAt(childIndex));</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            mSelectorRect.setEmpty();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        mBlockLayoutRequests = false;</div><div class="line"></div><div class="line">        invokeOnItemScrollListener();</div><div class="line"></div><div class="line">        return false;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这个方法接收两个参数，deltaY 表示从手指按下时的位置到当前手指位置的距离，incrementalDeltaY 表示据上次触发 event 事件手指在 Y 方向位置的改变量，这个值的正负表示用户是向上或者向下滑动，如果 incrementalDeltaY  小于0，说明是向下滑动，否者是向上滑动。</p>
<p>下面将会进行一个边界检测的过程，当 ListView 向下滑动的时候，就会进入一个 for 循环当中，从上而下依次获取子 View，如果子 View 的bottom 值已经小于 top 值，就说明这个子 View 已经移除屏幕，所以会调用 RecycleBin 的 addScrapView()  方法将这个 View 加入到废弃缓存当中，并将 count 计数器加1，计数器用于记录移出屏幕的子 View 的数量。那么如果是 ListView 向上滑动的话，其实过程是基本相同的，只不过变成了从下往上依次获取子 View ，然后判断该子 View 的 top 值是不是大于 bottom 值了，如果大于的话说明子 View 已经移出了屏幕，同样把它加入到废弃缓存中，并将计数器加1。</p>
<p>接下来根据当前计数器的值来调用 detachViewsFromParent() 方法，它的作用是把所有的移除屏幕的子 View  全部 detach 掉。紧接着调用了 offsetChildrenTopAndBottom() 方法，并将 incrementalDeltaY 作为参数，它的作用是让 ListView 中所有的子 View 都按照传入的参数值进行相应的偏移，这样就实现啦随着手指的移动，ListView的内容也会随着滚动的效果。</p>
<p>接下来进行判断，如果 ListView 中最后一个 View 的底部已经移入屏幕，或者 ListView 中的第一个 View 的顶部移入了屏幕，就会调用 fillGap() 方法，它的作用是用来加载屏幕外的数据。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * Fills the gap left open by a touch-scroll. During a touch scroll, children that</div><div class="line">     * remain on screen are shifted and the other ones are discarded. The role of this</div><div class="line">     * method is to fill the gap thus created by performing a partial layout in the</div><div class="line">     * empty space.</div><div class="line">     *</div><div class="line">     * @param down true if the scroll is going down, false if it is going up</div><div class="line">     */</div><div class="line">    abstract void fillGap(boolean down);</div></pre></td></tr></table></figure>
<p>这是一个抽象的方法，我们需要去 ListView 中去寻找，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * &#123;@inheritDoc&#125;</div><div class="line">     */</div><div class="line">    @Override</div><div class="line">    void fillGap(boolean down) &#123;</div><div class="line">        final int count = getChildCount();</div><div class="line">        if (down) &#123;</div><div class="line">            int paddingTop = 0;</div><div class="line">            if ((mGroupFlags &amp; CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) &#123;</div><div class="line">                paddingTop = getListPaddingTop();</div><div class="line">            &#125;</div><div class="line">            final int startOffset = count &gt; 0 ? getChildAt(count - 1).getBottom() + mDividerHeight :</div><div class="line">                    paddingTop;</div><div class="line">            fillDown(mFirstPosition + count, startOffset);</div><div class="line">            correctTooHigh(getChildCount());</div><div class="line">        &#125; else &#123;</div><div class="line">            int paddingBottom = 0;</div><div class="line">            if ((mGroupFlags &amp; CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) &#123;</div><div class="line">                paddingBottom = getListPaddingBottom();</div><div class="line">            &#125;</div><div class="line">            final int startOffset = count &gt; 0 ? getChildAt(0).getTop() - mDividerHeight :</div><div class="line">                    getHeight() - paddingBottom;</div><div class="line">            fillUp(mFirstPosition - 1, startOffset);</div><div class="line">            correctTooLow(getChildCount());</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>down 参数表示 ListView 是向下滑动还是向上滑动，如果向下滑动就调用 fillDown() 方法，如果向上滑动就调用 fillUp() 方法；我们太熟悉这两个方法，但是填充 ListView 是通过 调用 makeAndAddView() 方法来完成的，让我们仔细瞧瞧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * Obtains the view and adds it to our list of children. The view can be</div><div class="line">     * made fresh, converted from an unused view, or used as is if it was in</div><div class="line">     * the recycle bin.</div><div class="line">     *</div><div class="line">     * @param position logical position in the list</div><div class="line">     * @param y top or bottom edge of the view to add</div><div class="line">     * @param flow &#123;@code true&#125; to align top edge to y, &#123;@code false&#125; to align</div><div class="line">     *             bottom edge to y</div><div class="line">     * @param childrenLeft left edge where children should be positioned</div><div class="line">     * @param selected &#123;@code true&#125; if the position is selected, &#123;@code false&#125;</div><div class="line">     *                 otherwise</div><div class="line">     * @return the view that was added</div><div class="line">     */</div><div class="line">    private View makeAndAddView(int position, int y, boolean flow, int childrenLeft,</div><div class="line">            boolean selected) &#123;</div><div class="line">        if (!mDataChanged) &#123;</div><div class="line">            // Try to use an existing view for this position.</div><div class="line">            final View activeView = mRecycler.getActiveView(position);</div><div class="line">            if (activeView != null) &#123;</div><div class="line">                // Found it. We&apos;re reusing an existing child, so it just needs</div><div class="line">                // to be positioned like a scrap view.</div><div class="line">                setupChild(activeView, position, y, flow, childrenLeft, selected, true);</div><div class="line">                return activeView;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // Make a new view for this position, or convert an unused view if</div><div class="line">        // possible.</div><div class="line">        final View child = obtainView(position, mIsScrap);</div><div class="line"></div><div class="line">        // This needs to be positioned and measured.</div><div class="line">        setupChild(child, position, y, flow, childrenLeft, selected, mIsScrap[0]);</div><div class="line"></div><div class="line">        return child;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这里首先还是尝试调用 RecycleBin 的 getActiveView() 方法来获取子布局，只不过肯定是获取不到的了，因为在第二次 Layout 过程中我们已经从 mActiveViews 中获取过了数据，而根据 RecycleBin 的机制， mActiveViews 是不能够重复利用的，因此这里返回的值肯定是 null。</p>
<p>既然 getActiveView() 方法返回的值是 null，那么还是走到 obtainView() 方法中，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * Gets a view and have it show the data associated with the specified</div><div class="line">     * position. This is called when we have already discovered that the view</div><div class="line">     * is not available for reuse in the recycle bin. The only choices left are</div><div class="line">     * converting an old view or making a new one.</div><div class="line">     *</div><div class="line">     * @param position the position to display</div><div class="line">     * @param outMetadata an array of at least 1 boolean where the first entry</div><div class="line">     *                    will be set &#123;@code true&#125; if the view is currently</div><div class="line">     *                    attached to the window, &#123;@code false&#125; otherwise (e.g.</div><div class="line">     *                    newly-inflated or remained scrap for multiple layout</div><div class="line">     *                    passes)</div><div class="line">     *</div><div class="line">     * @return A view displaying the data associated with the specified position</div><div class="line">     */</div><div class="line">    View obtainView(int position, boolean[] outMetadata) &#123;</div><div class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;obtainView&quot;);</div><div class="line"></div><div class="line">        outMetadata[0] = false;</div><div class="line"></div><div class="line">        // Check whether we have a transient state view. Attempt to re-bind the</div><div class="line">        // data and discard the view if we fail.</div><div class="line">        final View transientView = mRecycler.getTransientStateView(position);</div><div class="line">        if (transientView != null) &#123;</div><div class="line">            final LayoutParams params = (LayoutParams) transientView.getLayoutParams();</div><div class="line"></div><div class="line">            // If the view type hasn&apos;t changed, attempt to re-bind the data.</div><div class="line">            if (params.viewType == mAdapter.getItemViewType(position)) &#123;</div><div class="line">                final View updatedView = mAdapter.getView(position, transientView, this);</div><div class="line"></div><div class="line">                // If we failed to re-bind the data, scrap the obtained view.</div><div class="line">                if (updatedView != transientView) &#123;</div><div class="line">                    setItemViewLayoutParams(updatedView, position);</div><div class="line">                    mRecycler.addScrapView(updatedView, position);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            outMetadata[0] = true;</div><div class="line"></div><div class="line">            // Finish the temporary detach started in addScrapView().</div><div class="line">            transientView.dispatchFinishTemporaryDetach();</div><div class="line">            return transientView;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        final View scrapView = mRecycler.getScrapView(position);</div><div class="line">        final View child = mAdapter.getView(position, scrapView, this);</div><div class="line">        if (scrapView != null) &#123;</div><div class="line">            if (child != scrapView) &#123;</div><div class="line">                // Failed to re-bind the data, return scrap to the heap.</div><div class="line">                mRecycler.addScrapView(scrapView, position);</div><div class="line">            &#125; else if (child.isTemporarilyDetached()) &#123;</div><div class="line">                outMetadata[0] = true;</div><div class="line"></div><div class="line">                // Finish the temporary detach started in addScrapView().</div><div class="line">                child.dispatchFinishTemporaryDetach();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (mCacheColorHint != 0) &#123;</div><div class="line">            child.setDrawingCacheBackgroundColor(mCacheColorHint);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (child.getImportantForAccessibility() == IMPORTANT_FOR_ACCESSIBILITY_AUTO) &#123;</div><div class="line">            child.setImportantForAccessibility(IMPORTANT_FOR_ACCESSIBILITY_YES);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        setItemViewLayoutParams(child, position);</div><div class="line"></div><div class="line">        if (AccessibilityManager.getInstance(mContext).isEnabled()) &#123;</div><div class="line">            if (mAccessibilityDelegate == null) &#123;</div><div class="line">                mAccessibilityDelegate = new ListItemAccessibilityDelegate();</div><div class="line">            &#125;</div><div class="line">            if (child.getAccessibilityDelegate() == null) &#123;</div><div class="line">                child.setAccessibilityDelegate(mAccessibilityDelegate);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</div><div class="line"></div><div class="line">        return child;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这里会调用 RecycleBin 的 getScrapView() 方法来尝试从废弃缓存中获取一个 View，这个 View 是存在的，因为在 trackMotionScroll() 方法中，一旦有任何子 View 被移出屏幕，就会将它加入到废弃缓存中，而从obtainView() 方法中的逻辑来看，一旦有新的数据需要显示到屏幕上，就会尝试从废弃缓存中获取 View 。所以它们之间就形成了一个生产者和消费者的模式，那么 ListView 神奇的地方也就在这里体现出来了，不管你有任意多条数据需要显示，ListView 中的子 View 其实来来回回就那么几个，移出屏幕的子View会很快被移入屏幕的数据重新利用起来，因而不管我们加载多少数据都不会出现 OOM 的情况，甚至内存都不会有所增加。</p>
<p>这里获取的 scrapView,我们将它作为第二个参数放在了 Adapter 的 getView() 方法中，我们都知道 getView() 的第二个参数是 convertView，因此，第一次加载时，convertView 为 null ，需要调用 inflater 加载布局，不等于 null 就可以直接利用 convertView，因为 convertView  就是我们之间用过的 View,移出屏幕进入到废弃缓存中，现在重新拿出来使用。然后我们只需要把 convertView 中的数据更新成当前位置上应该显示的数据，那么看起来就好像是全新加载出来的一个布局一样，从缓存中拿到子View之后再调用 setupChild() 方法将它重新attach到ListView当中，因为缓存中的View也是之前从ListView中detach掉的，这部分代码就不再重复进行分析了。</p>
<p>到目前为止，我们终于把 ListView 的源码整个过程梳理了一遍，希望大家都能够得到帮助。</p>
<p>参考文章：</p>
<p>1.郭霖 </p>
<p>[<a href="http://blog.csdn.net/guolin_blog/article/details/44996879" target="_blank" rel="external">http://blog.csdn.net/guolin_blog/article/details/44996879</a>]: </p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/04/25/经典算法-冒泡排序再优化/" rel="next" title="经典算法--冒泡排序再优化">
                <i class="fa fa-chevron-left"></i> 经典算法--冒泡排序再优化
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/04/16/AsnycTask-源码解析/" rel="prev" title="AsnycTask 源码解析">
                AsnycTask 源码解析 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="zhangzaidong" />
          <p class="site-author-name" itemprop="name">zhangzaidong</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">11</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#Adapter-的作用"><span class="nav-number">1.</span> <span class="nav-text">Adapter 的作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RecycleBin-机制"><span class="nav-number">2.</span> <span class="nav-text">RecycleBin 机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第一次-Layout"><span class="nav-number">3.</span> <span class="nav-text">第一次 Layout</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第二次-Layout"><span class="nav-number">4.</span> <span class="nav-text">第二次 Layout</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#滑动加载更多数据"><span class="nav-number">5.</span> <span class="nav-text">滑动加载更多数据</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhangzaidong</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-ribbon/canvas-ribbon.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  






  





  

  

  

  

  

</body>
</html>
